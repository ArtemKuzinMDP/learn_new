# Development Operations или DevOps  
администратор системы, инженер, который синхронизирует этапы создания программного продукта и отвечает за автоматизацию задач, связанных с настройкой и развертыванием приложений. Использует системы управления конфигурациями, решения виртуализации и облачные инструменты для балансировки ресурсов. Программное обеспечение - имеет последовательные этапы сборки, настройки, развертывания.

# 1. Для чего нужны ОС - операционные системы. 
При появление компьютеров и возникновении потребности в распределении  времени пользователей. С появлением файловой системы, динамического связывания, сегментно-страничной виртуальной памяти появилась и первая операционная система Multics. 
Она исполняет запросы команд на доступ данных, на ввод и вывод, выделение и освобождение памяти, загрузку программ в оперативную память и доступ к перифирийным устройствам. Управление оперативной памятью - она хранит и удаляет данные. Управление доступом к энергонезависимым носителям: жесткий диск, оптические диски. ОС организованны в той или иной файловой системе, обеспечивают пользовательский интерфейс, сохраняет ошибки. 
MS-DOS	Появился для работы на компьютерах PC IBM, имеет 3 основных компонента: io.sys - операционная система Дос, MSDOS.SYS  - обработка прерываний, COMMAND.COM - интерфейс командной строки. Вариативными являются CONFIG.SYS - конфигурация системы и загрузка драйверов. AUTOEXEC.BAT - стартовый пакетный файл при запуске. 

Типы ОС  по ядру ОС:
- Безядерные ОС позволяют программа напрямую обращаться к оборудованию. зачастую занимая один и тот же слот памяти. 
- В ядерных ос программы обращаются к ядру, которое выдает разрешенные потоки к оборудованию, тем самым структурируя запросы програм. ОС на ядре при переносе на другую архитектуру достаточно переписать только ядро. но не все программы. 

Каждое приложение имеет свое окружение, работают независимо, имеют свои доступы. Архитектура ядра: микро, монолит, гибрид. Различие - где работают драйвера, которые обеспечивают работу оборудования.
- Монолитные - его драйвера работают в пространстве ядра (UNIX, LINUX, FREE BSD), ошибка в одном драйвере вызовет ошибку вовсем ядре. понижает отказоустойчивость, но повышает скорость работы. 
- Микро - драйвера работают в отдельных пространствах и ядро обращается к каждому из них при необходимости (AIX, QNX, Minix), более стабильное, но медленнее, так как как процессор переключает контекст между разными программами.  
- Гибриды - (Windows, ReactOS, NeyWare) - можно спустить в пространство ядра нужные службы, а остальные в подпространства программ. 

Типы ОС по отношению к пользователям: 1. однопользовательские и однозадачные (в один момент - одна программа, только один тип пользователей, отсутствует разграничение доступов до своих ресурсов) 2. однопользовательская и многозадачная (в один момент может выполняться несколько программ, но все еще присутствует только один тип пользователей) 3. многопользовательские и многозадачные (в единицу времени может исполняться несколько программ, имеется механизм ограничения доступа до ресурса)

Кольца защиты и современные ОС.	Кольца защиты разделяют доступы на 4 кольца, что позволяет на аппаратном уровне разграничить опасность влияния программ, повышая отказоустойчивость. Есть три типа ресурса компьютера - память, командные инструкции и порты ввода/вывода. При переключение колец тратится очень много времени и ресурсов компьютера. Поэтому в современных ОС мы работаем почти всегда в кольце 3 - пользовательском кольце, а при необходимости установки драйверов или изменении ядра ОС - в кольце 0 - кольце операционной системы. Только на архитектуре х86 4 кольца защиты, на остальных - только 2, поэтому операционки и программы подстроены всегда под 2 кольца - пользователя и ядра. 
  
# 2.  История создания	и основы Линукс. 
Он взял принципы Юникс. который был разработан для 18ти битных компьютеров. UNIX создан Кеном Томпсоном и Деннисом Ритчи, создателем языка С, на котором написаны в том числе МакОС и Виндоус. Следы его работы во всех компьютерах. Задал стандарт всей ИТ отрасли. Написана на ассемблере, в 1975 переписана на языке С. Начало компьютерной эры с 1970 года. Юникс - основа для всех последующих ОС. Для каких-то напрямую, для каких-то в какой-то части.   
  
## Философия (всё есть файлы)	
- Нет никаких дисков. нет поддержки структурированных файлов ядром ОС. переменные окружения. клонирование текущего процесса со всем состоянием. Все файлы сходятся в одну точку - руут. система файлов в значении структуры каталогов операционной системы - древовидная. 
- Файл - поименованная область данных на диске. 
- В каталоге /dev располагается перечень блочных устройств, которые являются файлами, аналогичными дискам. Если название диска представляет собой только буквы, то это физический диск. Если в нем присутствуют цифры - то это логический диск, выделенный на физическом диске.  Virtual File System позволяет работать с физическими дисками через единую систему, не смотря на различия в файловых системах дисков. VFS дает единообразный доступ к файловым системам любым клиентским приложениям. Интерфес между ядром ОС и файловой системой конкретного диска. Чтобы обращаться к конкретным дискам не нужны специальные запросы, только драйверы переводчики с VFS на язык диска. 
- Нет устройств, есть файлы, связанные с устройством. Жесткий диск. порты, подключение к веб, каталоги; все это - в формате файлов. Файл - поток байтов, нет разрешений. 
Расширение в название только для удобства пользователя, чтобы понимать - исполняемый или неисполняемый файл перед нами. 
- Интерпритаторы команд различны, обычная программа - оболочка.  Командных интерпритаторов много - shel, bash, ksh, csh  и другие. просто приложение, не является частью ядра системы. будет выполнять то, что мы ей будет вводить. 
-  Имя файла может содержать 255 символов, расширение не важно, его не существует, есть типы и аттрибуты файлов. Если имя начинается с точки, то этот файл будет скрыт и не показываться при обычных запросах
- Конфигурационный файл - текстовый файл, который описывает параметры запуска приложения. В Юникс очень большой, так как содержит очень много комменатриев. Полный перечень действий, параметров и результатов. 
- Атомарные команды для конкретных действий. 
- Юникс проприетарная система - исходные коды недоступны общественности. Узкие и мощные отрасли: Банки, Биржи, Диспетчерские центры, космические полеты. Не позволяет делать системы. Более стабилен, чем Интел. На всех суперкомпьютерах стоят Линукс. 
  
## Философия (делайте хорошо): 
### - пишите хорошие программы, которые делают что-то одно; 
### - пишите программы, которые хорошо работают вместе; 
### - пишите программы, которые поддерживают текст, так как это универсальный интерфейс. 
  
Стандарт POSIX - В мире Unix есть стандарт Posix, Посикс - язык запросов программ к ядру ОС, и ядра ОС к оборудованию. Стандартная для всех ОС составляющая - единый язык обращения к ядру.  Программы пишут под ОС, а не под компьютер. У разных ос разные языки общения с программами. Каждая ОС имеет интерфейс общения с ядром. Посикс - набор стандартов, описывающих интерфейс между ОС Unix и прикладной программой. Создан для обеспечения совместимости программ на различных ОС, использующих его стандарты и переносимости приклодных программ на уровне исходного кода. Переводит с языка исходного кода - С на язык машин - бинарный код. Унификация интерфейсов взаимодействия во всех ОС такого типа. Сохраняет обратную совместимость с теми версиями, что были ранее. Находится в пользовательском пространстве. Стандарты Posix описывают системный интерфейс, командный интерпреттор, утилиты. 

Варианты UNIX.	Линукс лидирует на рынке серверов. Юникс используется на мощных промышленных компьютерах:
- ХП Супердом, который способен иметь 4 ТБ оперативной памяти, 128 ядер. Ни одна Интел система с таким не справится. Проблема - один блок, антитенденция - сейчас разбитие на много малых серверов. Без выключения можно сменить все, работает безпрерывно несколько 15-20 лет. 
- AIX на IBM power system.
- Solaris от Oracle. на архитектуре Sparc64, способные масштабироваться до 256 ядер.

# 3. Структура каталогов Линукс.
#### строгая иерархическая структура. все ветки ведутся от root, который является корневым, главным. в нем содержится каталоги 
- bin (утилиты для однопользовательского режима), 
- boot (файлы для загрузки ОС, для запуска и ядро), 
- dev (для работы с девайсами), 
- etc (общесистемные настройки ОС и служб ОС), 
- home (домашние директории пользователей), 
- lib (библиотеки для работы бинарных файлов), 
- media (точки монтирования для съемных файловых систем), 
- mnt (временно монтируемые файлы), 
- opt (дополнительное программное обеспечение), 
- proc (виртуальная файловая система, состояние ядра ОС в виде запущенных файлов), 
- root (домашний каталог пользователя - администратора для восстановления системы), 
- run (о системе в момент загрузки, все процессы, которые сейчас запущены), 
- sbin (основные системные программы для администрирования и настройки системы), 
- srv (данные для сервисов, предоставляемых системой), 
- sys (информация об устройствах и драйверах операционной системы, некоторые свойства ядра), 
- tmp (временные файлы), 
- usr (вторичная иерархия для пользовательских файлов, для сохранения менее важных файлов), 
- var (изменяемые файлы)
#### Директории в Linux
Все директории есть файлы, то есть являются просто потоком байтов, которые описывают поддиректории и файлы, которые в них содержатся. Каждый файл имеет путь, который начинается в корневом катологе root или /.
- Абсолютный путь - путь, который простраивается от корневого католога и может параллелен или удален от текущей директории. Начинается с /. Понятен в любом месте файловой системы. 
- Относительный путь - начинается с "." или с буквы и обращается только к директориям и файлам, находящимся в текущей директории. Может быть простроен только из текущей директории. 
#### Как устанавливается ПО в Linux - 3 варианта: 
- из исходных кодов, через компиляцию - возможность модифицировать ПО, установки без прав администратора в домашнюю директорию пользователя, при этом поиск зависимостей очень долгий, отсутствие контроля устанавливаемого ПО. При таком способе мы компилируем ПО в бинарные файлы, а бинарные файлы перепесывают соответствующие блоки в ядре ОС. 
- из пакетов, быстрая вещь, если все зависимости есть, то просто распаковка архива и перепись бинарного кода в нужных местах ОС. Пакет - готовый скомпилированый бинарный файл и список нужных зависимостей. Наличие контроля версий ПО. Есть пакетные менеджеры, которые распаковывают пакеты и контролируют версии. Пакетный менеджер хранит инфомрацию о версиях и списках установленных ПО. Нужны права администратора. Пакеты создаются под определенную версию, определенный дистрибутив Линукс. Пакетные менеджеры rpm для yum, dep для dppg.
- из репозитория. Наиболее приятный и распространенный способ - из репозитория. Место хранения файлов и библиотек, которое поддерживает потребность в зависимостях каждого ПО. Все зависимости в репозитории удовлетворены и сразу предлагает установить все нужное, спрашивает лишь занятие определенного места на компьютере. Репозиторий может быть Локальным или на сайтах - АппСторе, ПлейМаркет, Маркет.

# 4. Версии Linux.
Линукс - по сути только ядро ОС с возможностью как на конструкторе дособирать все нужные нам составляющие. Поэтому официальной версии Линукс не существует. Первую версию создал Линус Торвальдсон в 1991 году. Существует возможность через пользовательский интерфейс посикс обращаться к ядру из пространства пользователя. Линукс была доработана и обрела операционное окружение от GNU, важной частью которого был компилятор с языка С на язык машины. 
Официальное ядро - vanila kerner, которое можно получить на официальном сайте kerner.com. Распространяется на правах общественной лицензии, по которой каждый может получать и дорабатывать программное обеспечение, в том числе и ядро. ОС - ядро и набор программного обеспечения в структуре каталога, менеджер пакетов. Для изучения лучше брать ту ОС, на которую больше всего документации. 
#### Дистрибутивы - Варианты ядра и наполнения ОС: 
- Red Hat/CentOS/Fedora: Редхат подобоные системы: Red Hat - коммерческий продукт, свободная база, серверное направление, дополнения и обновления за деньги, есть поддержка за деньги, обновления не часты, основная забота - стабильность. CentOS - бесплатная версия для серверов, пакеты взаимозаменяемые, большое сообщество, но нет платной поддержки. Fedora - свободный полигон для испытания новых программ, меньший упор на стабильность и больший на новаторство, чаще подходят для персональных компьютеров.
- Debian/Ubuntu (как правило для ПК): Дебианподобные версии это Debian - расчитана на стабильность, пакеты свежее, чем в ред хат, но далеки от последих версий, для ПК. Ubuntu - максимально свежие и стабильные пакеты как правило для ПК. 
- Gentoo - только ручное управление, максимально гибкая.
- Slackware - не стоит никаких автоматизаций, только ручное управление. 
#### Сложности на пути изучения Linux:	
- непривычная структура файлов, 
- непривичное взаимодействие с программами, 
- длинные команды, 
- знание аттрибутов каждой команды, 
- огромные конфиги.
# 5.Базовые команды  Git
Все команды пишутся в следующем порядке: команда - ключи - аргументы (значения, названия). Разделителем всегда является пробел. Ключ начинается с "-" или "--" и указывает, как именно исполнить команду. 
Все есть файлы. Поэтому файлы можно группировать и разбирать по отдельным аттрибутам. 
Маска файла - определяет группу файлов, имеющих сходное строение названия. Например маска "(звездочка)2_o" удалит все файлы, которые оканчиваются на 2_o. а маска "file*" удалит все, которые начинаются на "file" Звездочка "*" заменяет любое число символов, а знак вопроса "?"  только один символ.
  
- Если в качестве ключа указать --help, то можно посмотреть справку по данной команде с описанием и всеми ключами, которые в ней есть
- echo - Выводит на экран указанное значение. В качестве аргумента можно ввести конкретное слово или фразу, тогда командная строка просто ее выведет. Также выводит переменные значения - текст, значение переменных, которые начинаются с $. Позволяет получить информацию о Переменных
- ls - вывод списка файлов в указанной директории. 
Имеет ключи:
    - -l - с описанием файлов. если в начале будет "-", то это файл, если в начале будет "d", то это директория, "l", то это link - ссылки. После этого обозначения идут 9 символов с отражением прав на файл. Число хард линк, имя пользователя, имя группы, размер, дата изменения, имя файла.
    - -la - вывод списка со скрытыми файлами, в формате с подробным описанием. если в начале будет "-", то это файл, если в начале будет "d", то это директория, "l", то это link - ссылки, если начинается с ".", то это скрытый файл.
    - -li - вывод списка с инфомрацией об inode файла. 
    - В качестве аргумента можно указывать любую директорию, тогда покажется состав именно этого каталога.
    - В качестве аргумента можно указать "..", тогда покажется содержимое вышестоящей директории. 
- pwd - выводит информацию о текущей директории. Важная информация для понимания текщего состояния. 
- cat - выводит на экран содержимое файла, который записан в ее аргументе. 
    - cat  .git/logs/** - показывает наполнение файла с логами ссылок - действий по изменению, удалению по конкретной ветке **
- touch - создание файла или обновление до текущего времени. Создает в текущей директории файл с названием после данной команды. Либо, если такой файл уже есть - то обновляет его время создание на сейчас. Можно указать через пробел несколько файлов, тем самым проработав с несколькими файлами.
- mkdir - создание директорий. Имеет возможности как создания одной директории, так и целой ветки директорий. 
    - Если после команды написать название директории, то произойдет создание новой директории с таким названием в текущей директории. Если через пробел указать несколько имен, то можно создать несколько директорий в текущей директории.
    - -p - данный ключ позволяет создавать несколько последовательных директорий. Если в аргументе через "/" указать несколько новых названий, то в текущей директории создастся директории, в ней еще одна и так далее, в зависимости, как глубоко вы прописали путь через "/". Вариант написания 'mkdir -p &&&/???/**' - создание ветки несуществующих директорий &&&, начиная с текущей директории. Следующие директории ??? и **. 
- cd - переход в нужную директорию. Если ввести ее без аргументов, то всегда попадаешь из любого места в домашнюю директорию пользователя, который установлен, как администратор. Если выбрать аргумент в виде любой директории. как вышестоящей. так и параллельной, то текущей рабочей директорией станет она. 
- rm - удаление конкретного файла, который не является директорией. удаляет файлы, но не директории. можно выбрать как конкретный файл с именем, так и группы файлов, которые попадают под маски. 
    - -r - удаление директории как файла, включая все его содержимое - поддиректории и файлы
    - -fr - удаление принудительное директорий, включая скрытые файлы и директории. в том числе и их поддиректории и файлы в них. 
- rmdir - удаление пустых директорий и только пустых директорий. если в директории есть скрытые файлы, то директория удалена не будет. 
- cp - копирует файл или директорию из одного места в другое. копирует со всеми аттрубутами, вплоть до времени создания. Аргументы - что и куда. Если папки, куда копировать не существует, то она создается.
    - -r - копирует рекурсивно директорию, то есть все, что в ней есть и ее саму в нужное место. Аргументы те же самые. Что и куда. Если папки, куда копировать не существует, то она создается. 
- mv - переносит файл или директорию из одного места в другое. При этом в исходном месте переносимый файл или директория удаляются. Аргументы - что и куда. Если данная команда используется на файл или директорию, то при введении нового имени файла в аргумент куда, то файл или директория просто переименуется. Если команда используется на директорию, которой не существует - директория создается. 
- type - интерпретирует тип команды, является ли она исполняемым файлом (hashed + путь к файлу), алиасом нескольких команд (aliased) или команды с ключами, или внутренней функцией командной строки (shell builtin), например Баш. 
- which - выводит на экран интерпретированный тип команды и расположение его исполняемого файла. Баш ищет значение команды сначала в своей библиотеке, потом в алиасах, потом в строгом соответствии с расположением в PATH в директориях, чем раньше в директориях найдет - на том и остановится. 
- whereis - выводит расположение исполняемого файла команды и файлы документации и конфигурации.
- who - кто сейчас работает на сервере - показывает имя пользователя, с какого терминала, когда и с какого адреса подключился. Для того, чтобы понять, одни ли работаете на сервере. К какому терминалу подключен. 
- man - полная подробная инструкция, как пользоваться той или иной командой. Пишется man и далее название команды. Часто ман равно хелп, но иногда ман более подробна и объемна. 
- id - команда. которая выводит информацию о пользователе, чье имя указано в аргументе этой команды. Покажет UID, GID, группы. в которые входит.
- sudo - позволяет выполнять команды от имени пользователей, в том числе от имени пользователя root.  
    - sudo -i / sudo su / sudo su $ИМЯ_ПОЛЬЗОВАТЕЛЯ - любая из команд переключит нас на пользователя root.
- usermod - команда, позволяющая осуществлять действия с настройками пользователей. имеет множество ключей для передачи и сокращения числа прав каждого из пользователей. 
- ln - создание Линка - еще одной записи в каталоге, еще одного имени файла, которая будет иметь ту же айноду и те же права, что и основной файл. Все хардлинки между собой равны и являются главными. При изменении прав или наполнения любого из хардлинков - меняются и все остальные. 
    - ln -s - создание мягкого линка - ярлыка файла. Права полные у всех. 
- date - текущие дата и время.
- uname - выводит информацию о версии ядра ОС 
- alias.&&& - объединение в алиас, где &&& - название алиаса
    - '!***;***'	после названия алиаса идет описание команды в ' ' и помечено ***, и если таких команд две, через точку с запятой, перед первым стоит ! восклицательный знак
    - '*' объединение в алиас, где после него идет описание команды в ' ' и помечено *
# 6. Работа с bash. Позволяет быстрее и точнее работать с оболочкой. 
#### - TAB - клавиша позволяет либо дополнять написанную команду или аргумент однозначным завершением. Либо при двойном нажатии вывести на экран список всех завершений. 
#### - ВВЕРХ - поиск предыдущих команд и автоматическое и занесение в текущую команду. Хранит до 500 команд, что очень удобно, если нужно быстро набрать ранее использованную команду, либо немного ее изменить. 
#### - Переменные окружения, которые содержат информацию о конфигурациях и настройках, влияющих на работу Линукс. 
- $HISTSIZE	переменная размера истории команд баш
- $PATH	показывает пути для поиска командной оболочкой исполняемых файлов. 
- $? выводит код возврата последней команды - если он равен 0, то команда выполнена корректно, если не 0 - команда выполнена с ошибкой, которую можно идентифицировать по выведенному числу.

# Связки команд
- Через логическое "и", где две и более команд будут выполнены вместе, но только если все они могут быть выполнены. Команды связываются значком &&. 
- Через логическое "или", где две и более команд сравниваются, пока хотя бы одна из них не выполняется - выполняются слева направо. Команды связываются значком ||.
- Через логическое "не имеет значения", где любые команды будут исполнены независимо от исполнения предыдущих. Команды связываются значком ;.

#### Утилиты для работы с файлами:
1. GREP - global regular expression print. утилита для поиска информации по конкретным ключам в конкретном файле. grep, далее в кавычках текст поиска, с учетом регистра, в конце файл, в котором нужно смотреть. -i убирает зависимость от регистра. 
2. head - выводит только верх файла, то есть первые строки. по умолчанию 10 строк, но с ключом -"число строк" можно вывести нужное число строк. Чтобы данная утилита с ключом числа строк работала всегда рекомендуется использовать в формате -n 3, где 3 число строк. 
3. tail - выводит последние строки файла. Те же самые ключи, что у head. Но есть еще ключ -f, который выводит нужное число последних строк и дальше следит за файлом, выдавая информацию о новых строках. Полезна для дебага или траблшутинга на нашем сервере. Выдает строчки с причинами ошибок и прочими данными. 
4. more - прочитывает нужный файл, можно просматривать постранично через пробел, или построчной через ентер. чтобы выйти - нажимаем Q.
5. less - прочитывает нужный файл, управление гораздо проще - можно стрелочками вверх и вниз, а также PageUp и PageDown. Можно организовать поиск по документу, для этого нажимаем "/" и вводим нужное слово. Слова в тексте выделяются. 
# 7. Пользователи в операционной системе Linux.
Имя пользователя - не длинее 32 символов, не может содержать : и новой строки. Это строка. Это псевдоним, который нужен для удобства пользователя. 
Для системы важен другой способ идентификации пользователя - UID  - Это числовое поле, которое может принимать числовое значение от 0 до 2 в 32 степени минус 1. Идентификация пользователя и его прав. Только по UID. 
Имена пользователя могут быть одинаковыми, но разные UID. Из-за этого система может ограничивать права доступа к ресурсам. 

В Линукс два вида пользователей: root, у которого UID=0. И все остальные, у которых UID больше 0.
Пользователь  root не имеет никаких ограничений, кроме технических. Единственный админский доступ, к которому не применяется никаких ограничений. Может менять, добавлять и удалять какие угодно файлы. 
Все остальные пользователи для удобства разделены на служебные и обычные, но для системы этого разделения нет. 

Для служебных выделяются специальные UID, под которыми они работают. Служебные относятся к программам, которые работают без взаимодействия с пользователями. Эти программы - демоны - запускаются самой системой и работают в фоновом режиме. Программа, ожидающая какого-то события и реагирующая на него. 
Все программы должны быть запущены от какого-то пользователя, если это будет пользователь root, то программа получит доступ ко всей системе, что небезопасно. 
Обычные полльзователи - люди, имеют домашние директории, ограничения по правам доступа. 

При попытке доступа в систему пользователь проходит снаала аутентификацию - сравнение логина и пароля с хранящимися в системе. А после авторизацию - на наличие прав доступа к программе или серверу. 

Файлы для хранения инфомрации о пользователях:
-  /etc/passwd - Содержит список пользователей с полями - имя, ИКС, UID пользователя, GID - идентификатор группы юзера, комментарий, домашний каталог пользователя, командная оболочка
- /etc/group - Содержит список всех групп, к которым отнесены пользователи данной системы. Формат отображения - имя, ИКС, GID - идентификатор группы, участники группы. 
- /etc/shadow - Хранит в себе ХЭШ - результат hash-функции, которая не имеет обратного преобразования. По сути - документ со всеми паролями, которые хранит система. Может быть открыта только под администратором. Хранение паролей не осуществляется, только преобразованный в хэш пароль. Поэтому восстановить пароль нельзя, можно только сбросить. 

У пользователей есть разные права по отношению к разным файлам. 
### Типы прав:
- чтение - (r)
- запись - (w)
- исполнение - (x)

Также права разделяются по отношению к владельцу файла: Сам пользователь, его группа пользователей, все остальные. 

Таким образом описание каждого файла при выводе полного отображения через list состоит из 9 символов, часть которых могут быть заменены "-", если данного права у данных пользователей нет. 

- rw-rw-rw- - все пользователи могут читать и изменять файл
-  rwx------ - только у владельца права на файл, остальные даже читать не могут.
-  rwxr--r-- - у владельца право на чтение, запись и исполнение, у остальных только чтение

Чтобы устанавливать данные права существует команда chmod, в аргументы которой можно писать через запятую все права, которые нужно добавить или убрать к конкретному файлу либо к директории (тогда после имени директории нужно поставить "/"). 

При изменении прав на директорию, права на ее содержание не изменяются. Но, если добавить ключ -R, то изменятся права на саму директорию и ее содержимое, в том числе в поддиректориях. Если у директории не будет прав на "r", то нельзя будет просмотреть список ее содержимого, но можно смотреть конкретные файлы в ней и работать. Если у директории не будет прав на "x", то нельзя открывать директорию и видеть информацию о ее содержимом кроме имен файлов. 

- чтобы поменять права владельца пишите u
- чтобы поменять права группы владельца - пишите g
- чтобы поменять права всех остальных - пишите o
- чтобы сразу поменять права для всех пользователей - пишите a

А дальше все, какие права нужно поменять "-" или "+" убрать или добавить. И какие именно права "r", "w", "x". 

#### Права можно поменять проставив в качестве аргумента для команды chmod числовое обозначение тех или иных прав

1. только исполнение 
2. только запись
3. только исполнение и запись
4. только чтение
5. только чтение и исполнение
6. только чтение и запись
7. все права

# 8 Файловая система

Для того, чтобы создать файл в системе необходимо выполнить 3 действия
- определить блок в 4кб в памяти диска - на файловой системе ext
- запретить иные операц с этим местом - хранится в inode - index node. 
- дать этому блоку название

В файле inode хранится вся инфомрация о файлах, в том числе права доступа. Можно посмотреть информацию о файле при помощи команды stat, в качестве аргумента - имя файла. Выведет всю информацию об этом файле. 

Число Айнодов ограничено, при необходимости их можно расширить, но самих по себе их определенное число. Также, для увеличения Айнодов нужно пересоздать файловую систему, что влечет потерю всех данных. При других файловых системах возможно динамическое выделенеие Айнодов. Например XFS. 

Чтобы увидеть свободное файловое пространство можно воспользоваться утилитой df - которая покажет информациюж о свободном месте. с ключом -i покажет свободные inod.

Имя файла хранится в каталоге, в котором показывается соответствие имени inod файла, а значит и его местоположение.  Директория и является таким каталогом, поэтому при запрете чтения директории мы не можем видеть названия файлов, которые в ней находятся. 

Соответственно, при удалении файла происходит удаление его имени из каталога и его inod освобождается, но не его данных, а также место он будет все еще занимать в файловой системе. Можно вручную просмотреть данные нужные нам на диске, но восстановить их как файл - невозможно. Потому что inod, в которой указаны ее местоположение и прочие аттрибуты уже свободна. Но данные можно восстановить вручную. 

### Файл существует до тех пор, пока существует хоть один хардлинк на него. Хардлинк - это запись, которая ссылается на этот файл. 
При использовании команды ls показывается число ссылок на файл. А это - прежде всего записи в различных каталогах и в нижестоящих и вышестоящих директориях. Хардлинки нельзя создавать на каталоги, хардлинки актуальны только в пределах одной файловой системы. Хардлинки не занимают блоков. Софтлинки - занимают место, так как являются новыми файлами, ссылающимися на другие файлы. Софтлинки очень часто используются в линукс. 

# 9 Работа с потоками
В Linux три стандартных потока данных:
#### STDIN - поток ввода = 0
#### STDOUT - поток вывода = 1 
#### STDERR - поток ошибок = 2

Поток ввода идет от внешнего оборудования, чаще всего клавиатура или мышь, к программе, сообщает требуемые операции. Программа реагирует через устройство вывода, чаще всего монитор или колонки, выводя корректные результаты обработки программой и ошибки. Чаще всего программы могут принимать и анализировать информацию из потоков других программ. В этом случае то, что для одной программы будет потоком вывода, для другой может стать потоком ввода. Мы можем направить их в файл или другую программу. Именно разделение потоков дает гибкость при работе с ними. Каждый поток имеет свой дискриптор, который для простоты называется номером потока. 

Чтобы направить определенную информацию не на монитор, а в файл, то мы можем использовать аргумент >, перед которым указать номер нужного потока. после этого символа через пробел необходимо указать файл, в который будет записана информация. Одновременно можно направлять поток и вывода, и ошибок, причем в разные файлы. Этот значок перезаписывает всю информацию в файле на новую. Чтобы добавить новую информацию к той, что уже есть, нужно ставить двойной знак >>. Работая с ним, как и прежде. Если файла ранее не существовало - он создастся вновь. 

Командная оболочка работает с командами перенаправления потоков справа налево, то есть сначала сверяет аргумент с теми данными, которые уже есть в системе, а в случае их отсутствия - создает новый файл. Далее интерпритирует команду направления потока и ее особенность. И только в самом конце рассматривает саму команду. При одновременном создании файла и операции с ним, важно помнить, что команда выполняется на момент создания, то есть до того, как на файл воздействовала команда. Это может привести к ошибкам при написании команд и неполучению желаемого результата.

Для перенаправления вывода одной программы на ввод другой программы необходимо ставить аргумент |, который называется пайп. Такие цепочки выполнения могут быть бесконечно долгими, что позволяет делать любые вещи в ОС. Для комбинирования нам не нужны промежуточные файлы, программы могут передавать поток вывода друг другу напрямую. 

Чтобы увидеть результат работы программы и на мониторе, и записать в файл необходимо воспользоваться командой tee. Если использовать ее чисто - то информация будет перезаписываться. Если указать ключ -a, то информация будет дополняться. 

Чтобы направить более одного потока в одно место необходимо использовать связку "1>___ 2>&1", где вместо ____ будет имя файла для перенаправления. Для подавления отдельного потока, то есть для вывода результатов определенной программы вникуда, используется место в системе Линукс, которое имеет адрес /dev/null. При направлении потока вывода или потока ошибок в него - все данные пропадут. 

# Курс по Linux. "Подготовительный курс Linux" от Андрея Буранова, OTUS
### Операционная система - общие сведения
- 0.0.	Введение
- 1.1.	Для чего нужна ОС
- 1.2.	Первая ОС . История Multics
- 1.3.	MS-DOS
- 1.4	Ядро ОС
- 1.5	Кольца защиты и современные ОС
- 1.6	Итоги

### UNIX
- 2.1	История создания
- 2.2	Философия (всё есть файлы)
- 2.3	Стандарт POSIX
- 2.4	Варианты UNIX
- 2.5	Итоги

### 
- 3.1	Структура каталогов
- 3.2	Как устанавливается ПО в Linux
- 3.3	Версии Linux
- 3.4	Сложности на пути изучения Linux

- 4.1	ls - Посмотреть список файлов в каталоге
- 4.2	touch - Создать файл
- 4.3	mkdir - Создать директорию
- 4.4	cd - Сменить текущую директорию
- 4.5	rm - Удалить файл
- 4.6	rmdir - Удалить директорию
- 4.7	cp - Копировать файл или директорию
- 4.8	mv - Переместить файл или директорию
- 4.9	type 
- 4.10	whereis -Узнать внутренняя или внешняя команда
- 4.11	who - Кто сейчас работает на сервере
- 4.12	man - Страница руководства
- 4.13	итоги

- 5.1	Идентификация пользователя (UID)
- 5.2	root и все остальные
- 5.3	etcpasswd
- 5.4	etcgroup
- 5.5	etcshadow
- 5.6	Права на файлы в Linux
- 5.7	chmod
- 5.8	Файловые системы и inode
- 5.9	Для чего нужны каталоги
- 5.10	HardLink и SoftLink
- 5.11	Итоги

- 6.1	grep
- 6.2	head
- 6.3	tail
- 6.4	more и less
- 6.5	Итоги

- 7.0	Работа с потоками
- 7.1	Перенаправление в файл - при помощи команды > или >>
- 7.2	Порядок выполнения команды в bash - справа налево
- 7.3	Перенаправление в STDIN другой команды - при помощи команды |
- 7.4	tee - вывести на экран и записать в файл
- 7.5	потоки и указатели
- 7.6	Итоги

- 8.1	Код возврата
- 8.2	и
- 8.3	или
- 8.4	не имеет значения
- 8.5	Итоги