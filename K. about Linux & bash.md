# Development Operations или DevOps  
администратор системы, инженер, который синхронизирует этапы создания программного продукта и отвечает за автоматизацию задач, связанных с настройкой и развертыванием приложений. Использует системы управления конфигурациями, решения виртуализации и облачные инструменты для балансировки ресурсов. Создание пайплайнов - автоматизированных последовательностей этапов, выполняемых для доставки приложения от команды разработчиков до конечного пользователя. Первые шаги для Линукс инженера: Устройство компьютера, Устройство Linux, Файловая система, Работа с BASH, Сети и сетевой стек. 

Старт для изучения Linux и Git. 
- Изучаем, что такое операционные системы и знакомимся с их отношением к устройству компьютера - https://www.youtube.com/watch?v=hb9CTGSJm88&list=WL&index=3. 
- Качаем виртуалбокс (VB) на https://download.virtualbox.org/virtualbox/7.0.12/VirtualBox-7.0.12-159484-Win.exe. Это виртуальная машина, которая позволит запустить Linux под Windows. 
- Качаем образ Fedora linux на https://archives.fedoraproject.org/pub/archive/fedora/linux/releases/36/Workstation/x86_64/iso/Fedora-Workstation-Live-x86_64-36-1.5.iso , для этого достаточно 2 ядра и 2гб. Ставим Fedora в виртуалбоксе по инструкции или самостоятельно https://websetnet.net/ru/how-to-install-fedora-in-virtualbox-with-steps-for-usb-clipboard-and-folder-sharing/ . 
- Регистрируемся на GitHub по ссылке https://github.com/ . Создание и привязка репозитория: чтобы создать SSH ключ для GitHub - запустить команду ssh-keygen в Bash - 5 раз Enter - далее cat ~/.ssh/***.pub - скопировать текст ключа. Чтобы подключить ключ в GitHub - идем в настройки - ключи SSH - новый SSH ключ. Далее создать репозиторий - название репозитория - создать - копируем SSH ссылку. подключение к созданному репозиторию. 
- Далее скачиваем Visual Studio Code - с ним работаем так: сделали изменения - сохранили - перешли на  Source Control - сделали коммит - сделали синк или пуш. Далее можно формировать собственный конспект по пройденным темам, для этого можно создать документ расширения .md. Для понимания всех возможностей в нем можно изучить инструкции по ссылкам https://gist.github.com/Jekins/2bf2d0638163f1294637. Для тренировки ветвения в Git можно использовать тренажер https://learngitbranching.js.org/. 
- Далее необходимо изучить курсы по сетям, например такой: https://www.youtube.com/playlist?list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1 или https://www.youtube.com/playlist?list=PLhUar1yMUpOuFKesVjs3hcyp3lu8cr7fD 
- Важная часть - курс по Ansible. https://www.youtube.com/playlist?list=PLg5SS_4L6LYufspdPupdynbMQTBnZd31N, который нужно обязательно проходить параллельно с практикой.

# 1. Для чего нужны ОС - операционные системы. 
При появление компьютеров и возникновении потребности в распределении  времени пользователей. С появлением файловой системы, динамического связывания, сегментно-страничной виртуальной памяти появилась и первая операционная система Multics. 
Она исполняет запросы команд на доступ данных, на ввод и вывод, выделение и освобождение памяти, загрузку программ в оперативную память и доступ к перифирийным устройствам. Управление оперативной памятью - она хранит и удаляет данные. Управление доступом к энергонезависимым носителям: жесткий диск, оптические диски. ОС организованны в той или иной файловой системе, обеспечивают пользовательский интерфейс, сохраняет ошибки. 
MS-DOS	Появился для работы на компьютерах PC IBM, имеет 3 основных компонента: io.sys - операционная система Дос, MSDOS.SYS  - обработка прерываний, COMMAND.COM - интерфейс командной строки. Вариативными являются CONFIG.SYS - конфигурация системы и загрузка драйверов. AUTOEXEC.BAT - стартовый пакетный файл при запуске. 

Типы ОС  по ядру ОС:
- Безядерные ОС позволяют программа напрямую обращаться к оборудованию. зачастую занимая один и тот же слот памяти. 
- В ядерных ос программы обращаются к ядру, которое выдает разрешенные потоки к оборудованию, тем самым структурируя запросы програм. ОС на ядре при переносе на другую архитектуру достаточно переписать только ядро. но не все программы. 

Каждое приложение имеет свое окружение, работают независимо, имеют свои доступы. Архитектура ядра: микро, монолит, гибрид. Различие - где работают драйвера, которые обеспечивают работу оборудования.
- Монолитные - его драйвера работают в пространстве ядра (UNIX, LINUX, FREE BSD), ошибка в одном драйвере вызовет ошибку вовсем ядре. понижает отказоустойчивость, но повышает скорость работы. 
- Микро - драйвера работают в отдельных пространствах и ядро обращается к каждому из них при необходимости (AIX, QNX, Minix), более стабильное, но медленнее, так как как процессор переключает контекст между разными программами.  
- Гибриды - (Windows, ReactOS, NeyWare) - можно спустить в пространство ядра нужные службы, а остальные в подпространства программ. 

Типы ОС по отношению к пользователям: 1. однопользовательские и однозадачные (в один момент - одна программа, только один тип пользователей, отсутствует разграничение доступов до своих ресурсов) 2. однопользовательская и многозадачная (в один момент может выполняться несколько программ, но все еще присутствует только один тип пользователей) 3. многопользовательские и многозадачные (в единицу времени может исполняться несколько программ, имеется механизм ограничения доступа до ресурса)

Кольца защиты и современные ОС.	Кольца защиты разделяют доступы на 4 кольца, что позволяет на аппаратном уровне разграничить опасность влияния программ, повышая отказоустойчивость. Есть три типа ресурса компьютера - память, командные инструкции и порты ввода/вывода. При переключение колец тратится очень много времени и ресурсов компьютера. Поэтому в современных ОС мы работаем почти всегда в кольце 3 - пользовательском кольце, а при необходимости установки драйверов или изменении ядра ОС - в кольце 0 - кольце операционной системы. Только на архитектуре х86 4 кольца защиты, на остальных - только 2, поэтому операционки и программы подстроены всегда под 2 кольца - пользователя и ядра. 
  
# 2.  История создания	и основы Линукс. 
Он взял принципы Юникс. который был разработан для 18ти битных компьютеров. UNIX создан Кеном Томпсоном и Деннисом Ритчи, создателем языка С, на котором написаны в том числе МакОС и Виндоус. Следы его работы во всех компьютерах. Задал стандарт всей ИТ отрасли. Написана на ассемблере, в 1975 переписана на языке С. Начало компьютерной эры с 1970 года. Юникс - основа для всех последующих ОС. Для каких-то напрямую, для каких-то в какой-то части.   
  
Философия (всё есть файлы)	
- Нет никаких дисков. нет поддержки структурированных файлов ядром ОС. переменные окружения. клонирование текущего процесса со всем состоянием. Все файлы сходятся в одну точку - руут. система файлов в значении структуры каталогов операционной системы - древовидная. 
- Файл - поименованная область данных на диске. 
- В каталоге /dev располагается перечень блочных устройств, которые являются файлами, аналогичными дискам. Если название диска представляет собой только буквы, то это физический диск. Если в нем присутствуют цифры - то это логический диск, выделенный на физическом диске.  Virtual File System позволяет работать с физическими дисками через единую систему, не смотря на различия в файловых системах дисков. VFS дает единообразный доступ к файловым системам любым клиентским приложениям. Интерфес между ядром ОС и файловой системой конкретного диска. Чтобы обращаться к конкретным дискам не нужны специальные запросы, только драйверы переводчики с VFS на язык диска. 
- Нет устройств, есть файлы, связанные с устройством. Жесткий диск. порты, подключение к веб, каталоги; все это - в формате файлов. Файл - поток байтов, нет разрешений. 
Расширение в название только для удобства пользователя, чтобы понимать - исполняемый или неисполняемый файл перед нами. 
- Интерпритаторы команд различны, обычная программа - оболочка.  Командных интерпритаторов много - shel, bash, ksh, csh  и другие. просто приложение, не является частью ядра системы. будет выполнять то, что мы ей будет вводить. 
-  Имя файла может содержать 255 символов, расширение не важно, его не существует, есть типы и аттрибуты файлов. Если имя начинается с точки, то этот файл будет скрыт и не показываться при обычных запросах
- Конфигурационный файл - текстовый файл, который описывает параметры запуска приложения. В Юникс очень большой, так как содержит очень много комменатриев. Полный перечень действий, параметров и результатов. 
- Атомарные команды для конкретных действий. 
- Юникс проприетарная система - исходные коды недоступны общественности. Узкие и мощные отрасли: Банки, Биржи, Диспетчерские центры, космические полеты. Не позволяет делать системы. Более стабилен, чем Интел. На всех суперкомпьютерах стоят Линукс. 
  
Философия (делайте хорошо): 
- пишите хорошие программы, которые делают что-то одно; 
- пишите программы, которые хорошо работают вместе; 
- пишите программы, которые поддерживают текст, так как это универсальный интерфейс. 
  
Стандарт POSIX - В мире Unix есть стандарт Posix, Посикс - язык запросов программ к ядру ОС, и ядра ОС к оборудованию. Стандартная для всех ОС составляющая - единый язык обращения к ядру.  Программы пишут под ОС, а не под компьютер. У разных ос разные языки общения с программами. Каждая ОС имеет интерфейс общения с ядром. Посикс - набор стандартов, описывающих интерфейс между ОС Unix и прикладной программой. Создан для обеспечения совместимости программ на различных ОС, использующих его стандарты и переносимости приклодных программ на уровне исходного кода. Переводит с языка исходного кода - С на язык машин - бинарный код. Унификация интерфейсов взаимодействия во всех ОС такого типа. Сохраняет обратную совместимость с теми версиями, что были ранее. Находится в пользовательском пространстве. Стандарты Posix описывают системный интерфейс, командный интерпреттор, утилиты. 

Варианты UNIX.	Линукс лидирует на рынке серверов. Юникс используется на мощных промышленных компьютерах:
- ХП Супердом, который способен иметь 4 ТБ оперативной памяти, 128 ядер. Ни одна Интел система с таким не справится. Проблема - один блок, антитенденция - сейчас разбитие на много малых серверов. Без выключения можно сменить все, работает безпрерывно несколько 15-20 лет. 
- AIX на IBM power system.
- Solaris от Oracle. на архитектуре Sparc64, способные масштабироваться до 256 ядер.

# 3. Структура каталогов Линукс.
строгая иерархическая структура. все ветки ведутся от root, который является корневым, главным. в нем содержится каталоги 
- bin (утилиты для однопользовательского режима, двоичные файлы и программы для загрузки и функционирования системы), 
- boot (образ начального диска с драйверами для загрузки и сам загрузчик, файлы для загрузки ОС, для запуска и ядро Linux), 
    - /boot/grub/grub.conf - настройка загрузчика.
    - /boot/grub/menu.lst - настройка загрузчика. 
    - /boot/vmlinuz - ядро Linux
- dev (для работы с девайсами, содержит узлы устройств. Список всех устройств), 
- etc (общесистемные настройки ОС и служб ОС, системные конфигурационный файлы, коллекция сценариев командной оболочки со системными службами),
    - /etc/crontab - файл, определяющий время запуска автоматизированных заданий,
    - /etc/fstab - таблица устройств хранения и точек монтирования
    - /etc/passwd - список учетных записей пользователей
- home (домашние директории пользователей, только в этих папках пользователи могут создавать и редактировать файлы), 
- lib (библиотеки для работы бинарных файлов, основными системными программами), 
- lost+found (содержит данные для частичного восстановления повреждений в файловой системе. Если с системой ничего не происходило, то он будет пустым. Каждай раздел или устройство отформатированные  ext3 имеют тут каталог),
- media (точки монтирования для съемных файловых систем), 
- mnt (временно монтируемые файлы, в старых системах вручную), 
- opt (дополнительное программное обеспечение, в основном коммерческое ПО), 
- proc (виртуальная файловая система, состояние ядра ОС в виде запущенных файлов, является каталогом процессов, параметров ядра и драйверов. Можно рассмотреть деятельность компьютера с точки зрения ядра ОС), 
- root (домашний каталог пользователя - администратора для восстановления системы), 
- run (о системе в момент загрузки, все процессы, которые сейчас запущены), 
- sbin (основные системные программы для администрирования и настройки системы, выполняют жизненно важные задачи, запускаются только суперпользователем), 
- srv (данные для сервисов, предоставляемых системой), 
- sys (информация об устройствах и драйверах операционной системы, некоторые свойства ядра), 
- tmp (временные файлы, в некоторых системах принудительно очищается при перезагрузке), 
- usr (вторичная иерархия для пользовательских файлов, для сохранения менее важных файлов, хранятся все программы и файлы поддержки. Содержит дополнительные каталоги bin, lib, sbin, share, share/doc), 
- var (изменяемые файлы, базы данных, буферные файлы, почта пользователя),
    - /var/log - файлы журналов с записями о действиях в системе. 

Директории в Linux
Все директории есть файлы, то есть являются просто потоком байтов, которые описывают поддиректории и файлы, которые в них содержатся. Каждый файл имеет путь, который начинается в корневом катологе root или /.
- Абсолютный путь - путь, который простраивается от корневого католога и может параллелен или удален от текущей директории. Начинается с /. Понятен в любом месте файловой системы. 
- Относительный путь - начинается с "." или с буквы и обращается только к директориям и файлам, находящимся в текущей директории. Может быть простроен только из текущей директории. 

Как устанавливается ПО в Linux - 3 варианта: 
- из исходных кодов, через компиляцию - возможность модифицировать ПО, установки без прав администратора в домашнюю директорию пользователя, при этом поиск зависимостей очень долгий, отсутствие контроля устанавливаемого ПО. При таком способе мы компилируем ПО в бинарные файлы, а бинарные файлы перепесывают соответствующие блоки в ядре ОС. 
- из пакетов, быстрая вещь, если все зависимости есть, то просто распаковка архива и перепись бинарного кода в нужных местах ОС. Пакет - готовый скомпилированый бинарный файл и список нужных зависимостей. Наличие контроля версий ПО. Есть пакетные менеджеры, которые распаковывают пакеты и контролируют версии. Пакетный менеджер хранит инфомрацию о версиях и списках установленных ПО. Нужны права администратора. Пакеты создаются под определенную версию, определенный дистрибутив Линукс. Пакетные менеджеры rpm для yum, dep для dppg.
- из репозитория. Наиболее приятный и распространенный способ - из репозитория. Место хранения файлов и библиотек, которое поддерживает потребность в зависимостях каждого ПО. Все зависимости в репозитории удовлетворены и сразу предлагает установить все нужное, спрашивает лишь занятие определенного места на компьютере. Репозиторий может быть Локальным или на сайтах - АппСторе, ПлейМаркет, Маркет.

# 4. Версии Linux.
Линукс - по сути только ядро ОС с возможностью как на конструкторе дособирать все нужные нам составляющие. Поэтому официальной версии Линукс не существует. Первую версию создал Линус Торвальдсон в 1991 году. Существует возможность через пользовательский интерфейс посикс обращаться к ядру из пространства пользователя. Линукс была доработана и обрела операционное окружение от GNU, важной частью которого был компилятор с языка С на язык машины. 
Официальное ядро - vanila kerner, которое можно получить на официальном сайте kerner.com. Распространяется на правах общественной лицензии, по которой каждый может получать и дорабатывать программное обеспечение, в том числе и ядро. ОС - ядро и набор программного обеспечения в структуре каталога, менеджер пакетов. Для изучения лучше брать ту ОС, на которую больше всего документации. 

Дистрибутивы - Варианты ядра и наполнения ОС: 
- Red Hat/CentOS/Fedora: Редхат подобоные системы: Red Hat - коммерческий продукт, свободная база, серверное направление, дополнения и обновления за деньги, есть поддержка за деньги, обновления не часты, основная забота - стабильность. CentOS - бесплатная версия для серверов, пакеты взаимозаменяемые, большое сообщество, но нет платной поддержки. Fedora - свободный полигон для испытания новых программ, меньший упор на стабильность и больший на новаторство, чаще подходят для персональных компьютеров.
- Debian/Ubuntu (как правило для ПК): Дебианподобные версии это Debian - расчитана на стабильность, пакеты свежее, чем в ред хат, но далеки от последих версий, для ПК. Ubuntu - максимально свежие и стабильные пакеты как правило для ПК. 
- Gentoo - только ручное управление, максимально гибкая.
- Slackware - не стоит никаких автоматизаций, только ручное управление. 

На 2024 самые популярные и удобные дистрибутивы - Fedora, Debian, менее известные, но уже сильные проекты LMDE, ARCH Linux, кроме того доступные обычным пользователям российские дистрибутивы - ALT Linux и Calculate Linux

Ubuntu и Fedora имеют возможность запускаться с Live CD, но данный способ работы дистрибутива медленнее, хоть и проще и не требует установки на диск. Кроме того настройка Linux на ноутбуке сложнее и имеет ряд ограничений. 

Сложности на пути изучения Linux:	
- непривычная структура файлов, 
- непривичное взаимодействие с программами, 
- длинные команды, 
- знание аттрибутов каждой команды, 
- огромные конфиги.

# 5.Базовые команды  Git
Все команды пишутся в следующем порядке: команда - ключи - аргументы (значения, названия). Разделителем всегда является пробел. Ключ начинается с "-" или "--" и указывает, как именно исполнить команду. 
Все есть файлы. Поэтому файлы можно группировать и разбирать по отдельным аттрибутам. 
Маска файла - определяет группу файлов, имеющих сходное строение названия. Например маска "(звездочка)2_o" удалит все файлы, которые оканчиваются на 2_o. а маска "file*" удалит все, которые начинаются на "file" Звездочка "*" заменяет любое число символов, а знак вопроса "?"  только один символ. При появлении знака Звездочки, командная оболочка подставляет в эту маску любые доступные ей значения. Знак "^" обозначает начало строки.
Также можно использовать следующие вариаенты переменных
[abcd] - любой перечень входящий в перечень
[!abcd] -  любой символ не входящий в перечень
[[:класс:]] Любой один символ, принадлежащий указанному классу
    [:alnum:] Любой алфавитно-цифровой символ
    [:alpha:] Любой алфавитный символ
    [:digit:] Любой цифровой символ
    [:lower:] Любая буква в нижнем регистре
    [:upper:] Любая буква в верхнем регистре
[![:класс:]] Любой один символ, принадлежащий указанному классу

При работе со множествами в выводе команд потребуется знание фигурных скобок {}. Установив их можно получить множесто, в том числе соединенное с другими множестами. Например:
1) {1..5} выведет цифры 1 2 3 4 5. 
2) {1..5}test выведет 1test 2test 3test 4test 5test. 
3) {1..3}test-{1..3} выведет 1test-1 1test-2 1test-3 2test-1 2test-2 2test-3 3test-1 3test-2 3test-3. 
4) {1,4,6} выведет 1 4 6. 
Пробел всегда прекращает работу с множеством. 
Указывая для команд мы можем указывать $(что-то), тогда команда отработает на том, что подразумевается под "что-то". 
Подстановка параметров, подстановка значений арифметических выражений и подстановка команд все еще выполняются в двойных кавычках. Без кавычек командная оболочка воспринимает все смены положения - пробелы, ввод, смена строки, табуляция, как разделитель слов, поэтому выводит результат в строку строго с одним пробелом между разделенными символами. 
Одиночные кавычки подавляют все правила командной оболочки, выводя маскимально то, что передано. Если нужно экранировать только один символ - перед этим символом ставится знак "\".

Кроме того есть Управляющие последовательности, приданные от прошлых программ: \a Звонок («предупреждение» — заставляет компьютер подать звуковой сигнал), \b Забой (backspace), \n Новая строка (в Unix-подобных , системах этот символ выполняет перевод строки), \r Возврат каретки, \t Табуляция. 

- Если в качестве ключа указать --help, то можно посмотреть справку по данной команде с описанием и всеми ключами, которые в ней есть

### Работа с терминалом:
- history - выводит историю всех команд, которые были сделаны. после команды написать цифру, выведет столько последних строк, сколько цифра.
    - Для применения полученной информации вы можете вводить ! и номер строки с нужной командой и это команда выполнится. Это особенно актуально, если команды длинные. 
- cal - выводит календарь текущего месяца
- echo - Выводит на экран указанное значение. В качестве аргумента можно ввести конкретное слово или фразу, тогда командная строка просто ее выведет. Также выводит переменные значения - текст, значение переменных, которые начинаются с $. Позволяет получить информацию о Переменных.
    - -e включает управляющие последовательности после обратного слеша
- echo $? - вывод кода возврата последней команды, выводит код возврата последней команды - если он равен 0, то команда выполнена корректно, если не 0 - команда выполнена с ошибкой, которую можно идентифицировать по выведенному числу.
    - в формате $(()) может выводить результат арифметических вычислений. кроме сложения, вычитания, умножения и деления умеет "%" Деление по модулю или остаток от деления, "**" Возведение в степень
- man - полная подробная инструкция, как пользоваться той или иной командой. Пишется man и далее название команды. Часто ман равно хелп, но иногда ман более подробна и объемна. Поставив цифру перед искомой командой можете посмотреть конкретный раздел мануала: 1 Пользовательские команды, 2 Программные интерфейсы системных вызовов в ядре, 3 Программные интерфейсы в библиотеке C, 4 Специальные файлы, такие как узлы устройств и драйверы, 5 Форматы файлов, 6 Игры и развлечения, такие как хранители экрана, 7 Прочее, 8 Команды системного администрирования.
    - -k покажет глобальный поиск по мануалам с искомым значением. 
- vi - вывод текстового редактора. vi &&& вывод текстового редактора для файла с именем &&&	текстовый редактор, встроенный в баш. вызов. открытие. ":" в текстовом редакторе для вызова панели управления. ":q" - выход из тектового редактора. ":q!" - принудительный выход из тектового редактора. ":w" - записать изменения.
- less - режим просмотра в терминале.Управление - стрелки, Пейдж ап и даун. Q - выход. Через / поиск по документу. прочитывает нужный файл, управление гораздо проще - мможно стрелочками вверх и вниз по строкам, а также PageUp и PageDown по страницам. G - возврат к концу документа, g - возврат к началу документа. через "/" можно искать ближайший такой набор символов, а следующие вниз искать через "n". Можно организовать поиск по документу, для этого нажимаем "/" и вводим нужное слово. Слова в тексте выделяются. H - вывод справки. 
- more - постраничный вывод файла или результата процесса в терминале. Вниз листать можно, вверх - нет. Прочитывает нужный файл, можно просматривать постранично через пробел, или построчной через ентер. чтобы выйти - нажимаем Q.
- clear - очистка экрана терминала
- cd - переход в нужную директорию. Если ввести ее без аргументов, то всегда попадаешь из любого места в домашнюю директорию пользователя, который установлен, как администратор. Если выбрать аргумент в виде любой директории. как вышестоящей. так и параллельной, то текущей рабочей директорией станет она. 
- type - интерпретирует тип команды, является ли она исполняемым файлом (hashed + путь к файлу), алиасом нескольких команд (aliased) или команды с ключами, или внутренней функцией командной строки (shell builtin), например Баш. 
- which - выводит на экран интерпретированный тип команды и расположение его исполняемого файла. Баш ищет значение команды сначала в своей библиотеке, потом в алиасах, потом в строгом соответствии с расположением в PATH в директориях, чем раньше в директориях найдет - на том и остановится. 
- whereis - выводит расположение исполняемого файла команды и файлы документации и конфигурации.
- alias - объединение в алиас. Команда без аргументов выведет список текущих псевдонимов в командной оболочке.
    - alias.&&& '!???;???'	объединение в алиас, где &&& - название алиаса, а после него идет описание команды в ' ' и помечено ???, и таких команд две, через точку с запятой, перед первым стоит ! восклицательный знак
    - alias.&&& '???' - , где &&& - название алиаса, а после него идет описание команды в ' ' и помечено ???
- apropos - выводит список подходящих услуг не всегда точная, делает тоже, что и man -k
- info - выводит информацию из справочника INFO, который содержит древовидную структуру с гиперссылками на другие статьи
- whatis - выводит в одну строку описание команды
- help - получение справки о команде, встроенной в систему может быть введен после команды с "--" перед собой, в этом случае выведет синтаксис, а может стоять как команда, тогда будет только описание
- zless - чтение файлов формата gz Включает в себя расширение, способное читать запакованные текстовые файлы gzip.
- unalias - снимает алиас с определенного набора команд
- sort - сортирует строки текста сортировка происходит по базовому принципу - алфавит, можно настроить
- uniq - сообщает о повторяющихся строках или удаляет их -d с этим ключом показывает дублирующиеся строки убирает из вывода только уникальные строки без дублей
- printenv - выводит список доступных в системе переменных
- script - запись в файл целых сеансов работы с командной строкой  
- find  - поиск по системе	-user &&& - поиск файлов, чьим владельцем является &&&. 
- shutdown 	- останавливает или перезагружает систему
- printenv - выводит часть или все окружение, чтобы оценить количество переменных и их значения можно отсортировать нужные переменные или вывести значение конкретной переменной
- set - выводит переменные и окружения, и командной оболочки		установка параметров командной оболочки
- export - экспорт окружения для отложенных программ		
- nano - вызов текстового редактора		
- mc - вызов утилиты Midnight Commander для управления файла в формате двухэкранного менеджера
- exit - выход из консоли

### Поиск информации:
- date - текущие дата и время.
- uname - выводит информацию о версии ядра ОС 
- ls - вывод списка файлов в указанной директории. 
Имеет ключи:
    - -l - с описанием файлов. если в начале будет "-", то это файл, если в начале будет "d", то это директория, "l", то это link - ссылки. После этого обозначения идут 9 символов с отражением прав на файл. Число хард линк, имя пользователя, имя группы, размер, дата изменения, имя файла.
    - -la - вывод списка со скрытыми файлами, в формате с подробным описанием. если в начале будет "-", то это файл, если в начале будет "d", то это директория, "l", то это link - ссылки, если начинается с ".", то это скрытый файл.
    - -li - вывод списка с инфомрацией об inode файла. 
    - В качестве аргумента можно указывать любую директорию, тогда покажется состав именно этого каталога.
    - В качестве аргумента можно указать "..", тогда покажется содержимое вышестоящей директории. 
- lsblk - выдает информацию о блочных устройствах в системе, показывает, отображает, выводит блочные устройства в системе
    - -o UUID покажет ЮИДы дисков без привязки к конкретному. 	
- pwd - выводит информацию о текущей директории. Важная информация для понимания текщего состояния. 
- stat - вывод информации о файле, выводит информацию из айноды файла, показывая номер айноды, тип, размер, число блоков, доступы, юид, гид, даты действий с файлом, его права.
- df - показывает свободное пространство файловых систем/ диск фри, свободное место на диске, сколько места на диске, какое свободное место есть на диске. 
    - df -i - показывает свободное пространство в айнодах. 
- wc - подсчет слов. Выводит число символов перевода строки, слов и байтов в каждом указанном файле
    - wc -l - подсчет строк	
- grep - global regular expression print. утилита для поиска информации по конкретным ключам в конкретном файле. grep, далее в кавычках текст поиска, с учетом регистра, в конце файл, в котором нужно смотреть. -i убирает зависимость от регистра. 
- head - выводит только верх файла, то есть первые строки. по умолчанию 10 строк, но с ключом -"число строк" можно вывести нужное число строк. Чтобы данная утилита с ключом числа строк работала всегда рекомендуется использовать в формате -n 3, где 3 число строк. 
- tail - выводит последние строки файла. Те же самые ключи, что у head. Но есть еще ключ 
    - -f, который выводит нужное число последних строк и дальше следит за файлом, выдавая информацию о новых строках. Полезна для дебага или траблшутинга на нашем сервере. Выдает строчки с причинами ошибок и прочими данными. Выход из режима отслеживания черех CTRL+С.

### Работа с файлами:
- file - показывает тип файла
- touch - создание файла или обновление до текущего времени. Создает в текущей директории файл с названием после данной команды. Либо, если такой файл уже есть - то обновляет его время создание на сейчас. Можно указать через пробел несколько файлов, тем самым проработав с несколькими файлами.
- fallocate - создает файлы определенного размера	fallocate -l 10MB file1 создаст файл file1 размером 10 мб
- mkdir - создание директорий. Имеет возможности как создания одной директории, так и целой ветки директорий. 
    - Если после команды написать название директории, то произойдет создание новой директории с таким названием в текущей директории. Если через пробел указать несколько имен, то можно создать несколько директорий в текущей директории.
    - -p - данный ключ позволяет создавать несколько последовательных директорий. Если в аргументе через "/" указать несколько новых названий, то в текущей директории создастся директории, в ней еще одна и так далее, в зависимости, как глубоко вы прописали путь через "/". Вариант написания 'mkdir -p &&&/???/**' - создание ветки несуществующих директорий &&&, начиная с текущей директории. Следующие директории ??? и **. 
- mv - переносит файл или директорию из одного места в другое. При этом в исходном месте переносимый файл или директория удаляются. Аргументы - что и куда. Если данная команда используется на файл или директорию, то при введении нового имени файла в аргумент куда, то файл или директория просто переименуется. Если команда используется на директорию, которой не существует - директория создается. При перемещении в директорию можно указывать несколько файлов.
    - -u - копирует только те файлы, которые имеют более свежую дату или отсутствуют в новом каталоге. 
    - -i - спросить, если потребуется перезаписать старый файл.
- cat - выводит на экран содержимое файла, который записан в ее аргументе. 
    - cat  .git/logs/** - показывает наполнение файла с логами ссылок - действий по изменению, удалению по конкретной ветке **
    - cat> файл (даже новый) и далее можно записать все, что нужно в терминале. Ctrl+d. Вход из режима записи. 
    - cat file1>file2. Перезапишет файл 2 данными из файл 1. 
    - cat file1>>file2. Дополниn файл 2 данными из файла 1.
- cp - копирует файл или директорию из одного места в другое. копирует со всеми аттрубутами, вплоть до времени создания. Аргументы - что и куда. Если папки, куда копировать не существует, то она создается. Можно копировать несколько файлов, в качестве места можно указать файл, тогда он заменится, можно указать директорию, тогда в ней создадутся или заменятся файлы.
    - -r - копирует рекурсивно директорию, то есть все, что в ней есть и ее саму в нужное место. Аргументы те же самые. Что и куда. Если папки, куда копировать не существует, то она создается. 
    - -u - копирует только те файлы, которые имеют более свежую дату или отсутствуют в новом каталоге.
    - -a - копирует со всеми идентификаторами и правами, иначе будет ставиться по умолчанию. 
    - -i - спросить, если потребуется перезаписать старый файл.
- rm - удаление конкретного файла, который не является директорией. удаляет файлы, но не директории. можно выбрать как конкретный файл с именем, так и группы файлов, которые попадают под маски. Можно просто указать перечень файлов для удаления. Система не позволяет отменить удаление, поэтому внимательно проверяйте, лучше через команду ls список файлов, которые будут удалена, и только после этого заменяйте ls на rm.
    - -i - запрашивать разрешение на удаление файла.
    - -r - удаление директории как файла, включая все его содержимое - поддиректории и файлы
    - -fr - удаление принудительное директорий, включая скрытые файлы и директории. в том числе и их поддиректории и файлы в них. 
- rmdir - удаление пустых директорий и только пустых директорий. если в директории есть скрытые файлы, то директория удалена не будет. 
- chmod - изменение прав на файл или директорию. для владельца, группы владельца и всех остальных. Может быть как в буквеннов формате, так и цифрами. смена прав, установка прав на чтение, исполнение, запись.
    - chmod -x &&& - редактирование прав на файл, на невозможность исполнения. где &&& - имя файла. 
    - chmod +x &&& - редактирование прав на файл, на возможность исполнения. где &&& - имя файла. 

### Пользователи:
- who - кто сейчас работает на сервере - показывает имя пользователя, с какого терминала, когда и с какого адреса подключился. Для того, чтобы понять, одни ли работаете на сервере. К какому терминалу подключен.
- whoami. показывает текущего активного пользователя.
- id - команда. которая выводит информацию о пользователе, чье имя указано в аргументе этой команды. Покажет UID, GID, группы. в которые входит.
- sudo - позволяет выполнять команды от имени пользователей, в том числе от имени пользователя root.  
    - sudo -i / sudo su / sudo su $ИМЯ_ПОЛЬЗОВАТЕЛЯ - любая из команд переключит нас на пользователя root.
    - -l - позволяет посмотреть все разрешения на действия от имени суперпользователя для текущего пользователя. 
- usermod - команда, позволяющая осуществлять действия с настройками пользователей. имеет множество ключей для передачи и сокращения числа прав каждого из пользователей. 
- umask определяет разрешение файлов по умолчанию при их создании
- su запуск командной оболочки от другого пользователя -с - запуск конкретной одной команды от имени суперпользователя чаще всего от суперпользователя, для начала - требуется ввести пароль того пользователя, под кем хотите войти. Запускает новую командную оболочку
- chown изменение владельца файла только от имени суперпользователя. Синтаксис - присвоить права владельца: 
1) просто имя = пользователю, 
2) имя:группа = пользователю и группе, 
3) имя: = пользователю и его группе. 
4) :группа = группе
- chgrp изменение группы файла только от имени суперпользователя, только группу меняет владельца. устарела.
- passwd - изменение пароля пользователя изменяет пароль указанного пользователя
- w - вызывает список залогиненных пользователей и их аптаймы

### Работа с каталогами:
- ln - создание Линка - еще одной записи в каталоге, еще одного имени файла, которая будет иметь ту же айноду и те же права, что и основной файл. Все хардлинки между собой равны и являются главными. При изменении прав или наполнения любого из хардлинков - меняются и все остальные. 
    - ln -s - создание мягкого линка - ярлыка файла. Права полные у всех. Перед началом файла, на который будет ссылка обязательно стаьте путь, можно "../"
- df -h - показывает подмонтированные диски с каталогами. Но не показывает каталоги связанные с другими каталогами, подмонтированные с функцией байнд.
- mount 	вывод каталогов в том числе в оперативной памяти, до катологов подмонтированных дисковых устройств. берет из католога /etc/mtab, который является симлинком на /proc/self/mounts, этот файл содержит точки монтирования.
    - sudo mount /dev/sda /mnt/ - подмонтирует sda из каталога dev в mnt, где хранятся временные блоки для работы с устройствами. Подмонтирование диска к определенной папке даст возможность работать с его данными через драйвера, не делая этого вручную.
    - --bind можно монтировать одну папку к другой.
- umount - чтобы отмонтировать диск от определенной папки.
- mkfs - определяет файловую систему раздела диска	
    - Например mkfs.ext4 и путь до файла логического диска (/dev/что-то)
- cfdisk - утилита для просмотра и создания логических дисков

### Пакеты и установка:
- ssh-keygen - генерация ключа для работы над репозиторием .pub - публичный .rsa - внутренний и личный
- yum - предоставление данных из системы пакетному менеджеру. установка, поиск программ программного обеспечения
    - -search поиск всех пакетов конкретной программы. 
    - -install под sudo установка нужного программного обеспечения, в конце названия программы ставим "d".
    - -provides находит все пакеты, относящиеся к даннму файлу. 
    - -remove удаление пакета, но не его зависимостей только под судо.
- rpm - работа с файлами в пакетах на диске, пакетный менеджер, поиск, удаление пакетов, сбор информации по файлам в пакете.
    - -ql поиск всех файлов в пакете. 
    - -qa вывод всех пакетов для поиска по ним. 
    - -e удаление пакета файлов.
- free - показывает свободное пространство в памяти в системе.
- du - сбор информации о размере занятой памяти.
    - du -sh показывает только размер всей памяти занятой. 
    - du -sh ??? - покажет размер конкретной директории или файла ???
- apt autoremove - удаляет программы, которые были установлены как зависимости, но изначальные программы уже удалены.
- apt dist-upgrade - обновление пакетов с зависимостями.
- apt install - установка конкретных файлов из пакетов.
- apt purge - удаляет из системы программу и ее конфигурационный файлы.
- apt remove - удаляет только саму программу из системы.
- apt update - обновление системы.
- apt upgrade - обновление существующих в системе пакетов.

### Работа с проектами:
- tree - вывод дерева проекта
    - -a выводит все директории с поддиректориями

### Процессы и управление
- top - показывает загрузку системы. В первой строчке показвается время сервера, сколько времени сервер без перезагрузки, сколько пользователей на нем. Load average - за минуту, за 5 минут, за 15 минут. Количество процессов в очереди на ожидание пользование ресурсами. Чем больше - тем более нагружена система.
- ps - показать список процессов. 
    - -e вывести все процессы в системе, 
    - -f показать полностью информацию, 
    - -l в длинном виде.
    - ps х - выводит процессы, независимо от терминалов, которые ими управляют
    - ps aux - выводит более подробную информацию о процессах. 
- pstree - показать дерево процессов в системе	
- vmstat - собирает статистику использования виртуальной памяти
- kill - посылание сигналов процессу. имеет формат -<signal> <PID>, где определяется какой сигнал какому процессу посылается. Чаще всего служит просто для закрытия процессов.
- jobs выводит список активных заданий
- bg переводит задание в фоновый режим работы либо можно сразу запускать программу в фоновом режиме, введя после нее знак &. После перевода или запуска фоном программа будет отражаться в списке работающих, будет иметь номер.
- fg переводит задание в режим работы на переднем плане возвращает указанную программу в активную оболочку. Имеет синтаксис fg %1, где 1 - номер процесса. "%1" Называется Спецификатором процесса.
- killall останавливает процессы по именам позволяет остановить сразу несколько процессов, например одного пользователя, или с одинаковым названием. 
- xload показывает изменения нагрузки на систему с течением времени
- tload показывает изменения нагрузки на систему с течением времени на графике
- strace - перехватывает и записывает любые системные вызовы, выполняемые командой. Кроме того, он также записывает любой сигнал Linux, отправленный процессу. Затем мы можем использовать эту информацию для отладки или диагностики программы.
- smartctl	проверка состояния дисков
 - smartctl -a &&& - проверка состояния конкретного диска &&&, которая включает общую информацию, но и информацию по использованию возможностей диска. 
- iostat - показывает информацию о данных, которые на жесткий диск пишутся, либо с него читаются	
- iotop - показывает информацию о процессах, которые на жесткий диск пишутся, либо с него читаются	
- uptime - показывает загрузку процессами жесткого диска, а также время работы сервера и дату последней загрузки	
- htop - показывает нагрузку процессора и загрузку системы в удобной утилите, с возможностью разных фильтров и приоритизации	
- systemctl - проврека  состояния сервера. 
 - systemctl status nginx - проверка состояния статуса и процессов сервера nginx

### Работа с потоками:
- tee - направление потока в файл и на экран, одновременное направление потока на экран и в файл с перезаписью файла
    - tee -a - одновременное направление потока вывода на экран и в файл без перезаписи	

### Сети
- ss - какие порты доступны на нашем сервере	
    - -t - соответствуют TCP/IP. 
    - -u - соответствует UDP. 
    - -n - показывает номера портов, а не их имена. 
    - -l - слушающие. 
    - -p - понять программу, слушающую порт, только от судо.
- netstat - сбор информации о сетевых соедиенениях	
    - netstat -tulpn информация про сервисы через интернет
- ip a - вывод информации об айпи серверах.	
    - ip addr show аналог команды.
- ip r - вывод информации о шлюзе.
- ifconfig	выдает информацию о состоянии активных интерфейсов, мак адреса, число пакетов через них
- ping 8.8.8.8 - диагностика работы сети, показывает уходят ли пакеты и принимаются ли. Остановка выполнения команды при помощи Ctrl+C.
- traceroute 8.8.8.8 - показывает путь от вашего сервера до конечного сервера, все промежуточные маршрутизаторы
- mtr 8.8.8.8 - показывает в реальном времени трассировку передачи пакетов с целью выявления потерь на определенных узлах

# 6. Работа с bash. Позволяет быстрее и точнее работать с оболочкой. 
- TAB - клавиша позволяет либо дополнять написанную команду или аргумент однозначным завершением. Либо при двойном нажатии вывести на экран список всех завершений. 
- ВВЕРХ - поиск предыдущих команд и автоматическое и занесение в текущую команду. Если в строку подставить !!, то она возмет полностью предыдущую команду. Хранит до 500 команд, что очень удобно, если нужно быстро набрать ранее использованную команду, либо немного ее изменить. 
- Переменные окружения, которые содержат информацию о конфигурациях и настройках, влияющих на работу Линукс. 
- $HISTSIZE	переменная размера истории команд баш, по умолчанию 1000
- $PATH	показывает пути для поиска командной оболочкой исполняемых файлов. 
- $? выводит код возврата последней команды - если он равен 0, то команда выполнена корректно, если не 0 - команда выполнена с ошибкой, которую можно идентифицировать по выведенному числу.

Чтобы дополнить переменную из командной оболочки необходимо прописать "название_переменной=$название_переменной&&&", где &&& заменяются на нужный текст, который необходимо придать переменной. Например Foo=$Foo1. В конце переменной Foo добавится "1". 

Связки команд
- Через логическое "и", где две и более команд будут выполнены вместе, но только если все они могут быть выполнены. Команды связываются значком "&&". 
- Через логическое "или", где две и более команд сравниваются, пока хотя бы одна из них не выполняется - выполняются слева направо. Команды связываются значком "||".
- Через логическое "не имеет значения", где любые команды будут исполнены независимо от исполнения предыдущих. Команды связываются значком ";".
- Через значок "|" связывается последовательность команд от первой до последней. Создание последовательности направления потока, направление нескольких потоков подряд из одной команды в другую, вывода второй на ввод в третью и так далее.
- ">" направление потока в файл	
- "<" обратное направление потока или принимает данные из вывода другой программы или файла. направления потока в конкретный файл, перезапись в нем всех предыдущих данных. перенаправление, запись. Обязательно указывать номер потока, так как по умолчанию это только 1 - вывод.
- ">>" направление потока в файл. направления потока в конкретный файл, дополнение в нем всех предыдущих данных. перенаправление, запись. Обязательно указывать номер потока, так как по умолчанию это только 1 - вывод.

Команды работают через командную строку, а вернее через командную оболочку - программу, которая компилирует понятный человеку текст в понятные машине запросы. 
Bash - базовая командная оболочка от GNU, которая стала доработанной версией shell из системы Unix. 
При работе с графическим эмулятором командная строка работает через эмулятор Терминала, который иногда для простоты называется Терминалом. 
Для ввода команд последняя строка должна содержать призыв к вводу, для этого в конце строки стоит знак $ для обычного пользователя и # для суперпользователя. 
При работе в командной строке можно ользоваться мышью выставляя курсор, зажатием левой кнопкой выделяется текст, а также двойным нажатием левой кнопкой выделенный текст копируется, а средней кнопкой вставляется. 

Для управления внутри терминала кроме команд есть наборы сочетаний клавиш, которые позволяют выполнять различные действия. Графическая оболочка иногда может перехватывать некоторые сочетания клавиш, но в чистом терминале они работают. 
- CTRL+A Перемещает курсор в начало строки. 
- CTRL+E Перемещает курсор в конец строки
- CTRL+F Перемещает курсор на один символ вперед; действует так же, как клавиша со стрелкой вправо
- CTRL+B Перемещает курсор на один символ назад; действует так же, как клавиша со стрелкой влево
- ALT+F Перемещает курсор на одно слово вперед
- ALT+B Перемещает курсор на одно слово назад
- CTRL+L Очищает экран и устанавливает курсор в левый верхний угол. То же самое делает команда clear

Все эти команды находятся в библиотеке Readline. Там же находятся операции вырезания и вставки: 
- CTRL+D Удаляет символ в позиции курсора. 
- CTRL+T Меняет местами два символа — в позиции курсора и предшествующий ему/
- ALT+T Меняет местами два слова — в позиции курсора и предшествующий ему
- ALT+L Переводит в нижний регистр символы, начиная с символа в позиции курсора и до конца слова
- ALT+U Переводит в верхний регистр символы, начиная с символа в позиции курсораи до конца слова
- CTRL+K Удаляет символы от позиции курсора до конца строки
- CTRL+U Удаляет символы от позиции курсора до начала строки
- ALT+D Удаляет символы от позиции курсора до конца текущего слова
- ALT+BACKSPACE Удаляет символы от позиции курсора до начала текущего слова. Если курсор находится в начале слова, удаляется предшествующее слово
- CTRL+Y Извлекает текст из кольцевого буфера удалений и вставляет его в позицию курсора

- ALT+? Выводит список возможных дополнений. В большинстве систем аналогичный эффект можно получить, нажав клавишу TAB второй раз, что намного проще
- ALT+* Вставит все возможные дополнения. Это пригодится в том случае, если требуется использовать больше одного возможного варианта дополнения

Кроме поиска истории команд и работы с ними через команды можно использовать сочетания клавиш:
CTRL+R - поиск по истории команд,
CTRL+J - копирование найденной информации.
CTRL+P Переход к предыдущей записи в истории. Действует так же, как клавиша со стрелкой вверх. 
CTRL+N Переход к следующей записи в истории. Действует так же, как клавиша со стрелкой вниз. 
ALT+< Переход в начало (к первой записи) списка истории.
ALT+> Переход в конец (к последней записи) списка истории.
CTRL+R Инкрементальный поиск в обратном порядке. Поиск выполняется поступательно, от текущей записи вверх по списку истории.
ALT+P Поиск в обратном порядке, не инкрементальный. При использовании этого вида поиска введите искомую строку и нажмите ENTER, и только после этого будет выполнен фактический поиск. 
ALT+N Поиск в прямом порядке, не поступательный.
CTRL+O Выполнить текущую команду в списке истории и перейти к следующей. Эту комбинацию удобно использовать, если требуется повторно выполнить последовательность команд из списка истории.

Командная оболочка хранит данные в переменных командной оболочки, которые инициированы ей самой, и переменных окружения, которые принадлежат всем остальным. Кроме того существуют данные в Псевдонимах и Функциях командной оболочки. Когда мы входим в систему, запускается программа bash и читает содержимое серии конфигурационных сценариев, называемых файлами запуска (startup files), где определяется окружение по умолчанию, общее для всех пользователей. Затем она читает дополнительные файлы запуска в вашем домашнем каталоге, где определяется личное окружение. В Командной оболочке входа bash читает /etc/profile и файл личного профиля пользователя. После процессы этой командной оболочки наследует Простая командная оболочка, которая уже читает /etc/bash.bashrc и личный пользовательский файл запуска ~/.bashrc. 

При работе с конфигурационными файлами нужно использовать текстовые редакторы, которых очень много, самые популярные: kedit, kwrite, nano, vi, vim, kate, gedit, emacs. Обязательно при редактировании конфигурационных файлов создавайте копии, которые обычно создают с пометками .bak, .sav, .old, .orig. Оболочка читает данные конфигурационного файла .bashrc только при запуске, а соответственно при изменениях нужно перезапустить программную оболочку. Изменения эти могут быть - новые псевдонимы, изменения значений переменных. Обязательно пишите комментарии, которые начинаются с # в начале строчки. А также убирайте не нужные строчки, выставляя перед ними #. Удаляйте в крайнем случае. 

# 7. Пользователи в операционной системе Linux.
Имя пользователя - не длинее 32 символов, не может содержать : и новой строки. Это строка. Это псевдоним, который нужен для удобства пользователя. 
Для системы важен другой способ идентификации пользователя - UID  - Это числовое поле, которое может принимать числовое значение от 0 до 2 в 32 степени минус 1. Идентификация пользователя и его прав. Только по UID. 
Имена пользователя могут быть одинаковыми, но разные UID. Из-за этого система может ограничивать права доступа к ресурсам. 

В Линукс два вида пользователей: root, у которого UID=0. И все остальные, у которых UID больше 0.
Пользователь  root не имеет никаких ограничений, кроме технических. Единственный админский доступ, к которому не применяется никаких ограничений. Может менять, добавлять и удалять какие угодно файлы. 
Все остальные пользователи для удобства разделены на служебные и обычные, но для системы этого разделения нет. 

Для служебных выделяются специальные UID, под которыми они работают. Служебные относятся к программам, которые работают без взаимодействия с пользователями. Эти программы - Демоны - программы, которые запускаются системой, работают в фоне, не взаимодействуют с пользователем. Программа, ожидающая в фоновом режиме какого-то события и реагирующая на него. 
Все программы должны быть запущены от какого-то пользователя, если это будет пользователь root, то программа получит доступ ко всей системе, что небезопасно. 
Обычные полльзователи - люди, имеют домашние директории, ограничения по правам доступа. 

При попытке доступа в систему пользователь проходит сначала аутентификацию - сравнение логина и пароля с хранящимися в системе. А после авторизацию - на наличие прав доступа к программе или серверу. 

Файлы для хранения инфомрации о пользователях:
-  /etc/passwd - Содержит список пользователей с полями - имя, ИКС, UID пользователя, GID - идентификатор группы юзера, комментарий, домашний каталог пользователя, командная оболочка. Отражает также права, которые есть у пользователя. 
- /etc/group - Содержит список всех групп, к которым отнесены пользователи данной системы. Формат отображения - имя, ИКС, GID - идентификатор группы, участники группы. Вносить изменения в права пользователей можно только от имени администратора. При помощи команды usermod.
- /etc/shadow - Хранит в себе ХЭШ - результат hash-функции, которая не имеет обратного преобразования. По сути - документ со всеми паролями, которые хранит система. Может быть открыта только под администратором. Хранение паролей не осуществляется, только преобразованный в хэш пароль. Поэтому восстановить пароль нельзя, можно только сбросить.  

У пользователей есть разные права по отношению к разным файлам. Типы прав:
- чтение - (r)
- запись - (w)
- исполнение - (x)

Также права разделяются по отношению к владельцу файла: Сам пользователь, его группа пользователей, все остальные. 

Таким образом описание каждого файла при выводе полного отображения через list состоит из 9 символов, часть которых могут быть заменены "-", если данного права у данных пользователей нет. 

- rw-rw-rw- - все пользователи могут читать и изменять файл
-  rwx------ - только у владельца права на файл, остальные даже читать не могут.
-  rwxr--r-- - у владельца право на чтение, запись и исполнение, у остальных только чтение

Чтобы устанавливать данные права существует команда chmod, в аргументы которой можно писать через запятую все права, которые нужно добавить или убрать к конкретному файлу либо к директории (тогда после имени директории нужно поставить "/"). 

При изменении прав на директорию, права на ее содержание не изменяются. Но, если добавить ключ -R, то изменятся права на саму директорию и ее содержимое, в том числе в поддиректориях. Если у директории не будет прав на "r", то нельзя будет просмотреть список ее содержимого, но можно смотреть конкретные файлы в ней и работать. Если у директории не будет прав на "x", то нельзя открывать директорию и видеть информацию о ее содержимом кроме имен файлов. 

- чтобы поменять права владельца пишите u
- чтобы поменять права группы владельца - пишите g
- чтобы поменять права всех остальных - пишите o
- чтобы сразу поменять права для всех пользователей - пишите a

А дальше все, какие права нужно поменять "-" или "+" убрать или добавить. И какие именно права "r", "w", "x". 

Права можно поменять проставив в качестве аргумента для команды chmod числовое обозначение тех или иных прав

1. только исполнение 
2. только запись
3. только исполнение и запись
4. только чтение
5. только чтение и исполнение
6. только чтение и запись
7. все права

# 8 Файловая система

Для того, чтобы создать файл в системе необходимо выполнить 3 действия
- определить блок в 4кб в памяти диска - на файловой системе ext
- запретить иные операц с этим местом - хранится в inode - index node. 
- дать этому блоку название

Файл - именновая область на диске, который занимает один или несколько блоков. Каждый блок это 4 килобайта или 4096 байт. Любые файлы в пределах этого значения будут занимать один блок.

stat - выводит информацию из айноды файла, показывая номер айноды, тип, размер, число блоков, доступы, юид, гид, даты действий с файлом, его права. Файловые системы ext. 

В файле inode хранится вся инфомрация о файлах, в том числе права доступа. Можно посмотреть информацию о файле при помощи команды stat, в качестве аргумента - имя файла. Выведет всю информацию об этом файле. 

Число Айнодов ограничено, при необходимости их можно расширить, но самих по себе их определенное число. Также, для увеличения Айнодов нужно пересоздать файловую систему, что влечет потерю всех данных. При других файловых системах возможно динамическое выделенеие Айнодов. Например XFS. 

Чтобы увидеть свободное файловое пространство можно воспользоваться утилитой df - которая покажет информациюж о свободном месте. с ключом -i покажет свободные inod.

Имя файла хранится в каталоге, в котором показывается соответствие имени inod файла, а значит и его местоположение.  Директория и является таким каталогом, поэтому при запрете чтения директории мы не можем видеть названия файлов, которые в ней находятся. 

Соответственно, при удалении файла происходит удаление его имени из каталога и его inod освобождается, но не его данных, а также место он будет все еще занимать в файловой системе. Можно вручную просмотреть данные нужные нам на диске, но восстановить их как файл - невозможно. Потому что inod, в которой указаны ее местоположение и прочие аттрибуты уже свободна. Но данные можно восстановить вручную. 

Файл существует до тех пор, пока существует хоть один хардлинк на него. Хардлинк - это запись, которая ссылается на этот файл. 
При использовании команды ls показывается число ссылок на файл. А это - прежде всего записи в различных каталогах и в нижестоящих и вышестоящих директориях. Хардлинки нельзя создавать на каталоги, хардлинки актуальны только в пределах одной файловой системы. Хардлинки не занимают блоков. Софтлинки - занимают место, так как являются новыми файлами, ссылающимися на другие файлы. Софтлинки очень часто используются в линукс. 

В каталоге dev располагается перечень блочных устройств, которые являются файлами, аналогичными дискам. Если название диска представляет собой только буквы, то это физический диск. Если в нем присутствуют цифры - то это логический диск, выделенный на физическом диске.  Virtual File System позволяет работать с физическими дисками через единую систему, не смотря на различия в файловых системах дисков. VFS дает единообразный доступ к файловым системам любых клиентских приложений. Интерфес между ядром ОС и файловой системой конкретного диска. Чтобы обращаться к конкретным дискам не нужны специальные запросы, только драйверы переводчики с VFS на язык диска. 

Монтировние - связка файла дискового устройства с каталогом, чтобы внутри линукс можно было с ним работать по привычным принципам дисков. монтирование - связка операционной системы и файловой системы диска. иерархическая система, которая должна быть смонтирована при первом запуске Линукс. для запуска линукс нужно монтирование. ядро монтирует в корневую и хранится в файле /etc/fstab, куда, в какой системе смонтировано, с каким ЮИД и сколько штук. именно диск vda1 монтируется в операционную систему для связи с ядром. 

Команда df -h показывает подмонтированные диски с каталогами. Но не показывает каталоги связанные с другими каталогами, подмонтированные с функцией bind. 
Команда mount выведет вывод каталогов в том числе в оперативной памяти, до катологов подмонтированных дисковых устройств. берет из католога /etc/mtab, который является симлинком на /proc/self/mounts, этот файл содержит точки монтирования. proc является каталогом процессов, параметров ядра и драйверов. 
- mount - в вариации "sudo mount /dev/sda /mnt/" подмонтирует sda из каталога dev в mnt, где хранятся временные блоки для работы с устройствами. Только от лица администратора это возможно, поэтому sudo. 

Подмонтирование диска к определенной папке даст возможность работать с его данными через драйвера, не делая этого вручную. umount - чтобы отмонтировать диск от определенной папки. с ключом  --bind можно монтировать одну папку к другой Можно монтировать и образы через  sudo mount ~/file.iso /mnt.

Установка программного обеспечения:
Пакетный менеджер для Линукс Цинтос - rpm (рпм): отвечает за локальную установку, строит базу данных о пакетах и обновлениях,  а yum (юм) - надстройка для рпм для работы с репозиториями и предоставляет данные пакетному менеджеру. 
Для поиска конкретных программ (например нужен http сервер, который называется apache) используем ключ search, при таком поиске покажутся все пакеты, относящиеся к такому серверу. 
Команда wc -l показывает число строк. Лучше всего отсортировать при помощи grep. 
Чтобы установаить программу используем yum, только с ключом install. Эту команду можно использовать только под root. Чтобы установить - в конце названия программы пишем "d" - demon. 
rpm с ключом -ql запускает список всех файлов в пакете. Бинарный файл в папке бин или сбин - скорее всего запускает программу, к нему можно посмотреть ман для изучения вариантов. А также conf для изучения конфигурации, по которой он запускается. 

Поиск пакета по файлу - нужно при сообщении системы о нехватке какого-либо файла, чтобы можно было найти, в каком пакете этот файл находится. используем команду yum с ключом provides. находит все каталоги и файлы. Если нужна исполняемая команда, то ищем каталог bin, и можно при помощи греп искать. Можно найти каталог и файл, а по ним посмотреть, какой пакет соответствует этому файлу. 
найти пакет и его состав через рпм. rpm с ключом -qa запускает список всех пакетов в системе. их можно посчитать через wc. 
Для удаления используем yum remove и привилегии судо. Удаляется только пакет, но не его зависимости. А также rpm -e, который удалит пакет. 

Дополнительные типы файлов
с -  Специальный файл символьного устройства. Файлы этого типа соответствуют устройствам, таким как терминал или модем, которые обрабатывают данные как потоки байтов
b - Специальный файл блочного устройства. Файлы этого типа соответствуют устройствам, таким как привод жесткого диска или CD-ROM, которые обрабатывают данные блоками

Работа с текстовыми файлами и их редактирование:

Самый распространенный текстовый редактор под Linux - vi, он входит в стандарт Posix, очень легковесный и доступен всегда. Был первым, кто заменил строчные текстовые редакторы, экранный. Имеет улучшенный вариант в виде vim, который подразумевается под командой vi в современных Linux системах. 

Команды внутри vi: :q - выход, :q! - принудительный выход. Если заблудились - нажмите два раза Esc. Vi - режимный редактор, поэтому сначала вы находитесь в режиме команд, что значит, что ввести текст можно только после перехода в режим вставки при помощи кнопки I (i). Esc - позволит выйти из режима редактирования. :w - сохранение изменений. 

VIM имеет два режима - совместимый с vi и полный. Для перехода в полный режим откройте его командой vim, или пропишите echo "set nocp" >> ~/.vimrc. Если vim вовсе отсутствует, то подгрузите его sudo apt-get install vim. 

Курсор перемещается стрелками, мышью, или кнопками HJKL. Кроме того много операторов перемещения курсора, из которых интересны SHIFT+G (G) - К последней строке в файле, число-SHIFT+G - К строке с указанным номером (например, команда 1G выполнит переход к первой строке в файле), 0 (ноль) - В начало текущей строки. 

Если вы не редактируете существующий файл, но создаете новый, то при записи через w просто вставьте путь и название файла и он создастся. Также редактирование можно начинать с команд o или a. В командном режиме нажмите U, чтобы отменить предыдущее изменение. vi отменяет только самую последнюю операцию. vim отменяет множество операций. В командном режиме удалять символы можно командой x, а целые строки командой dd. Вообще команда d имеет множество дополнений для удаления по разным признакам, например dG удалит все до последней строки. Но на самом деле d - вырезает текст, который можно позже вставить командой p. Просто копировать тест можно командой y. Команда y имеет такие же признаки, как и команда d. Команда J позволяет объединять строки. 

Команда f ищет следующий указанный символ в строке и переходит к нему, через ; можно продолжать поиск символа в данной строке. Команда / делает тоже, но во всем файле, только дальнейший поиск происходит через n. Команда, при которой можно заменять слова, следующая :%s/слово для замены/слово замена/g. где : - знак начала команды. % - определение диапазона строк. s - команда подстановки. g - определяет параметр во всех строках документа. Подставив в конец оператор c можно запрашивать подтверждение на каждую замену. 

Редактор vi позволяет открыть несколько файлов, просто перечислив их в аргументах команды через пробел. Для переключения между файлами используйте :n и :N. Переключаться можно только сохранив данные, поэтому можете просто добавлять ! в конце команды. Команда :buffer позволит посмотреть все редактируемые файлы или перейти к одному из них по номеру. Команда :e с именем другого файла откроет его дополнительно в текущем режиме. Команда :r НАЗВАНИЕ_ФАЙЛА вставит содержимое файла после текущей позиции курсора. Чтобы сохранить и выйти можно набрать ZZ, :wq

# 9 Работа с потоками
В Linux три стандартных потока данных:
STDIN - поток ввода = 0
STDOUT - поток вывода = 1 
STDERR - поток ошибок = 2

Это прямо физические файлы, в которые записываются данные по отработке тех или иных команд. 

Поток ввода идет от внешнего оборудования, чаще всего клавиатура или мышь, к программе, сообщает требуемые операции. Программа реагирует через устройство вывода, чаще всего монитор или колонки, выводя корректные результаты обработки программой и ошибки. Чаще всего программы могут принимать и анализировать информацию из потоков других программ. В этом случае то, что для одной программы будет потоком вывода, для другой может стать потоком ввода. Мы можем направить их в файл или другую программу. Именно разделение потоков дает гибкость при работе с ними. Каждый поток имеет свой дискриптор, который для простоты называется номером потока. 

Чтобы направить определенную информацию не на монитор, а в файл, то мы можем использовать аргумент >, перед которым указать номер нужного потока. после этого символа через пробел необходимо указать файл, в который будет записана информация. Одновременно можно направлять поток и вывода, и ошибок, причем в разные файлы. Этот значок перезаписывает всю информацию в файле на новую. Чтобы добавить новую информацию к той, что уже есть, нужно ставить двойной знак >>. Работая с ним, как и прежде. Если файла ранее не существовало - он создастся вновь. Направление может быть и обратным: может принимать данные из вывода другой программы или файла (например grep it '<' file1: Найдет все строки с символами it в файле 1)

Командная оболочка работает с командами перенаправления потоков справа налево, то есть сначала сверяет аргумент с теми данными, которые уже есть в системе, а в случае их отсутствия - создает новый файл. Далее интерпритирует команду направления потока и ее особенность. И только в самом конце рассматривает саму команду. При одновременном создании файла и операции с ним, важно помнить, что команда выполняется на момент создания, то есть до того, как на файл воздействовала команда. Это может привести к ошибкам при написании команд и неполучению желаемого результата.

Для перенаправления вывода одной программы на ввод другой программы необходимо ставить аргумент |, который называется пайп. Такие цепочки выполнения могут быть бесконечно долгими, что позволяет делать любые вещи в ОС. Для комбинирования нам не нужны промежуточные файлы, программы могут передавать поток вывода друг другу напрямую. 

Чтобы увидеть результат работы программы и на мониторе, и записать в файл необходимо воспользоваться командой tee. Если использовать ее чисто - то информация будет перезаписываться. Если указать ключ -a, то информация будет дополняться. 

Чтобы направить более одного потока в одно место необходимо использовать связку "1>___ 2>&1", где вместо ____ будет имя файла для перенаправления. Для подавления отдельного потока, то есть для вывода результатов определенной программы вникуда, используется место в системе Линукс, которое имеет адрес /dev/null. При направлении потока вывода или потока ошибок в него - все данные пропадут. 

В современных системах для вывода результатов потоков вывода и ошибок в одно место достаточно поспользоваться конструкцией &> или &>>. 

# Процессы в Linux
Процесс = программа, которая работает в данный момент. совокупность связанных действий, преобразующих входящие данные в исходящие. Программа - совокупность команд, понятных системе или процессору, совокупность программного кода и ресурсов для его выполнения - становятся уже процессом. 

Создать процесс можно только создав полную копию существующего процесса сделав системный вызов из него самого. Системный вызов с ядром ОС Линукс называется fork(). Стартует в одном процессе, завершается в двух. Далее системный код нужно заменить при помощи исполняемого вызова exec(), принимает имя файла и параметры, применяемые к нему, после чего мы получаем нужный нам процесс. После завершения отработки процесса ставится системный вызов exit(), который прекращает процесс, освобождает используемую им память, закрывает дискрипторы файла, сообщает код возврата процесса. Код возврата считывается системным вызовом wait(), который вызывается из исходного процесса, считывает код возврата и после этого процесс полностью исчезает из системы. Процесс, на основе которого был создан новый процесс называется родителем, а процесс, который был создан - называется потомком. 
  
PID, PPID	PID - уникальный номер идентификатор процесса в ОС, хранится в переменной целочисленного типа (int), где максимальное значение 32768. PPID - идентификатор родительского процесса. Каждый процесс должен иметь PID и PPID. Исключение - процессы init / systemd (PID = 1, PPID = 0) и kthreadd (PID = 2, PPID = 0). Init появляется во время старта ОС и вызван exec из ядра в пространство пользователя. Kthreadd - процесс в пространстве ядра. 

Процесс зомби - состояние процесса после екзит и до вейт. Уже не процесс, не занимает ничего, невозможно завершить, так как нечего завершать, только строчка - код возврата. Но зомби занимает лимит на процессы, выданные отдельным пользователям. Если у пользователя много зомби выбрали весь лимит, но новых процессов он запустить не сможет, новых программ открыть не сможет. Видно в утилите Ток, что показывает, что система высоконагруженная и время между экзит и вейт слишком велико. Это видно и по нагрузке сервера, по среднему числу процессов в очереди. Либо это может значить, что есть процесс, который не следит за своими потомками. Он их создает, но код возврата не считывает. Нужно найти такого родителя. 

Процесс сирота - родительский процесс завершен, соответственно PPID не обращается ни к какому процессу. С сиротами работает само ядро, как только его находит, делает его родительским процессом процесс ИНИТ. Невидим для нас. Как убить зомби? Закрыть родительский процесс, который не принимает коды возврата. Тогда процесс станет сиротой, ИНИТ заберет его коды возврата. Процесс не завершается даже в том случае, если процесс родитель завершен. Тогда новый процесс поменяет родителя, но продолжит выполняться. 

Доступ до ресурсов разграничивается на основе прав пользователей. А процесс - это совокупность файлов и данных. Есть каталог proc, в нем лежат все процессы. Все процессы видны всем. Управлять процессами могут владелец - то, кто создал процесс и пользователь рут. Сменить владельца процесса невозможно. В директории проц лежат файлы с названием равным ПИД процесса. Там можно посмотреть автора процесса - владельца подкаталога в проц. 

Демон - компьютерная программа, которая работает фоном без взаимодействия с пользователем. процесс, который не имеет управляющего терминала, не привязан к терминалу, только при помощи сигналов операционной системы можно им управлять. Также это программы, которые ждут какого-то события, а потом отрабатывают. Не важно, работает ли пользователь на сервере. демоны будут запущены и работать в фоновом режиме. В названии файла в конце если стоит буква d - это демон. Сделано это для программ, процессов, которые должны постоянно поддерживать работу системы. Имеют четкую точку ввода и вывода, независимые от терминалов ввода и вывода. 

kill - программа, которая посылает указанный сигнал определенному процессу. в формате kill -<signal>  <PID>. Любой сигнал завершает процесс, как правило цифровая константа. которая пишется после SIG, иногда имеет словесное отражение. Посикс определяет 28 сигналов, нам стоит помнить SIGINT  = 2 - прерывание, SIGTERM = 15 - завершение, или сигнал по умолчанию, SIGKILL = 9 - безусловное завершение. Кроме того есть 19 - приостановка и 18 - возврат к работе остановленного процесса. Некоторые программы в зависимости от кода могут земенять стандартные обработчики сигналов на свои, что позволит некоторые сигналы игнорировать. На сигнал 15 можно иногда ставить игнорирование, а еще 15 сигнал позволяет программе корректно завершиться  - завершит процессы, освободит файлы, пошлет сигналы и завершится по окончанию всех действий, то есть может потребоваться время. Сигнал 9 невозможно проигнорировать. он моментально отрубает процесс. Сигнал 9 не завершает только процессы d - ожидающие сигналы с устройства вывода, а также ИНИТ. Только в Линукс. В ЮНИКС можно послатть 9 сигнал на инит, перезагрузив систему. 

top - Утилита Линукс, показывающая загрузку системы. присутствует на всех системах семьи Юникс - выводит процессы, наиболее загружающие компьютер. 
- При наборе утилиты топ выводится список процессов в порядке уменьшения потребления времени процессора. 
- Динамический вывод, который обновляется каждые 3 секунды. Можно изменить, набрав S и набрав цифру, на что нужно изменить. 
- В первой строчке показвается время сервера, сколько времени сервер без перезагрузки, сколько пользователей на нем. 

Load average в первой строке показывает в расчете на минуту, на 5 минут, на 15 минут количество процессов в очереди на ожидание пользование ресурсами. Чем больше - тем более нагружена система. Если уменьшается - нагрузка на процессор падает. Если увеличивается - запущены какие-то трудоемкие процессы. Это число должно быть меньше или равно числу ядер процессора для Юникс подобных ОС. 

Нажав 1 - можно посмотреть загруженность каждого из ядер и их число - CPU. 
В Линукс другая ситуация - число лоад эвередж может быть больше, ведь в очередь попадают не только запущенные процессы, но и процессы, которые ожидают данных с устройств ввода - вывода. 
Обращение к недоступному сетевому ресурсу. Процесс получает статус D - , которые ожидает какие-то данные. Они на производительность не влияют, но лоад авередж занимают. 

- Вторая строка утилиты топ показывает число процессов всего и в разных статусах: всего, запущенных, спящих, остановленных, зомби. 
- На третьей строке параметры, которые показывают информацию об объеме потраченного времени:
    - sy - в пространстве ядра ОС, 
    - us - в пространстве пользователя, 
    - ni - на процессы с низким приоритетом (атавизм), 
    - id - простой времени, 
    - wa - на общение с устройством ввода вывода, ожидание данных, чаще всего с диском - самый уязвимый элеменет, 
    - hi - обработка аппаратных прерываний, 
    - si - обработка системных прерываний (напримерторент клиент генерирует, когда растет раздача)
    - st - для виртуальных машин, насколько хостовой сервис нагружен относительно процессорных ресурсов (гипервизор КВМ только общается с процессором, в отличает от других гипервизоров, который считает st)

ps	показать список процессов с ключами -e вывести все процессы в системе, -f показать полностью информацию, -l в длинном виде
pstree	показать дерево процессов в системе.

Состояния процессов, которые можно определить в выводе команды ps x: 
- R Выполняется. Процесс выполняется или готов к выполнению. 
- S Приостановлен. Процесс временно не выполняется; скорее всего, находится в ожидании определенного события, такого как нажатие клавиши или прибытие сетевого пакета. 
- D Приостановлен без возможности прерывания. Процесс ожидает завершения операции ввода/вывода, например, дисковым устройством. 
- T Остановлен. Процесс принудительно остановлен (подробнее об этом рассказывается ниже). 
- Z Недействующий процесс-«зомби». Это дочерний процесс, который завершился, но не был удален родителем. 
- < Высокоприоритетный процесс. Существует возможность наиболее важным процессам выделить больше процессорного времени. Данное свойство процесса называется niceness (уступчивость). Про процессы с более высокими приоритетами говорят, что они менее уступчивы, потому что потребляют больше процессорного времени, оставляя меньше другим процессам. 
- N Низкоприоритетный процесс. Процесс с низким приоритетом (или уступчивый процесс) получает процессорное время только после того, как будут обслужены процессы с более высоким приоритетом. 

Для того, чтобы остановить процесс, который запущен на данный момент в терминале нужно нажать Ctrl+C. 
Комбинация Ctrl+Z позволяет приостановить программу, запущенную в терминале. 

Работа с инициализацией в Linux:

Последовательность событий после запуска компьютера: 
1) сначала программа BIOS проверяет готовность оборудования, проверка систем, 
2) BIOS смотрит в область диска MBR - Master Boot Record - главная загрузочная запись, откуда считывает загрузчик операционной системы. Содержит код загрузки и таблицы разделов. Можно создавать загрузочную область физически на диске. 
3) Запуск GRub - Grand Unifer Bootloader - мощная программа, имеющая доступ до дисков, умеет загружать Линукс, а также передавать права другому загрузчику, например, чтобы загрузить Виндоус. Основная задача - загрузить ядро операционной системы из кодов загрузки. 
4) Загрузка ядра операционной системы. Далее, операционная система должна подмонтировать к корневому каталогу физическая файловая система, для этого обязательно должен быть драйвер. В иных случаях в корневую папку монтируется сначала вместо физического диска initrd. Сюда мы уже можем положить модули и драйверы, которые позволят ядру считать физическую файловую систему. Но чаще мы можем добавлять нужные драйвера напрямую в ядро и собирать операционную систему так, как нам нужно. 
5) Запуск системы инициализации Init или сейчас Systemd. Запускается после запуска ядра, определяет порядок запуска служб и программ, является для всех родителем. Три самые популярные системы инициализации: 
    1 - SysV с 1983 года - набор простых стартовых скриптов по поводу того где и что стартовать и что хранить, Каталоги /etc/rc... определяют последовательность старта разных служб. 
    2 - Upstart, призвана упростить написание стартовых скриптов, сама от себя запускала все службы, но не получила широкого распространения. 
    3 - systemd - упорядоченный процесс запуска служб, который в отличае от предыдущих мог быть параллельным для нескольких программ, последовательность запуска только через зависимости, при незапуске службы - продолжает пытаться запустить программу. Файлы системы инициализации хранятся в /etc/init.d и представляют собой обычный скрипты - сборки программ, которые описывают разные задачи. Каталог для систем инициализации /lib/systemd/system/. Отошла от принципа простых программ. Каждая служба имеет все нужное в себе - нужные ссылки, последовательность запуска.  
6) Запуск пользовательских команд. 

# Сеть

Команда ip a - вывод информации об айпи сервера. 
Команда ip r - вывод информации о шлюзе - пути, по которому пойдут пакеты, не предназначенные для нашей локальной сети. 
Для понимания DNS-сервиса - программы, которая выводит соответствие домена сетевому IP-адресу, к которому сеть обращается. 
Адрес DNS-сервера указывается в специальном файле /etc/resolv.conf. По умолчанию соответствует базовому маршруту - адресу роутера. 
Команда ss -tnlp показывает, какие порты доступны на нашем сервере. 

10) Работа в Git.

Что такое Git	Git - это репозиторий, система контроля версий, распределенное хранилище истории разработки с возможностью обмена данными между всеми участниками разработки, обнаруживает и решает ошибки и конфликты версий разработчиков, а также интеграцию с другими версиями. Нецентрализованная и распределенная система, у каждого пользователя свой, они обмениваются ими через как раз репозиторий. Но могут быть через центральный сервер, например GitHub.

Скачиваемые пакеты, можно взять с git-scm.com. Под Linux используйте пакеты apt-get install git или yum install git.

Управлять Git можно через командную строку или инструменты написания кода, такие как текстовый редактор, можно использовать стандартный vim, можно Visual Studio Code. 

Чтобы выбрать директорию, в командной строке прейдите командой cd в директорию проекта path/to/project или через меню правой кнопки мыши выбрать открыть в нужной командной строке.

Создание репозитория	Создание репозитория происходит через команду git init в указанной директории создастся база данных и настройки для Git, чтобы можно было с ней работать. 

Установка конфигураций проходит через команду git config  и указание нужной конфигурации. Для начала это почта и имя пользователя.

Локальные данные конфигурации GIT находятся в документе .git/config в директории проекта. Они по умолчанию записываются. Чаще всего данные имени и имени актуальны для всех проектов, поэтому их можно записать в папке пользователя в ~/.gitconfig через добавление переменной --global. Системный порядок конфигурации хранится в /etc/gitconfig и устанавливаются через переменную --system:

- локальные (проект, находятся в папке проекта), 
- глобальные (пользователя, находятся в папке пользователя)
- системные (общие, хранятся в etc/getconfig). 

установка при помощи команд --local, --global и --system

Стирание данных в конфигурационных файлах через --unset, если стирается конкретный параметр, и --remove-section, если стирается вся секция о пользователе. 

Алиасы - сокращенное написание отдельных команд или команд с атрибутами, либо можно делать сразу наборы команд, поставив перед первым в списке !, а команды прописать через ;. 

Добавление файлов и индексация	Добавление файлов и индексация в только что созданный репозиторий  При работе с GIT работаем с тремя зонами - рабочей директорией, а также Индексом GIT и самим Репозиторием. В Индексе все файлы, которые GIT отслеживает. Через команду git status мы можем посмотреть состояние репозитория и отслеживаемых и неотслеживаемых файлов. Untracked - не отслеживаются вовсе. To be commited - в Индексе, но не в Репозитории. При статусе Clean все три области - Рабочая директория, Индекс и Репозиторий соответствуют друг другу. Команды git add - добавляет файлы из рабочей директории в Индекс, а команда git commit - добавляет файлы из Индекса в Репозиторий. После удачного срабатывания git commit мы также получим идентификатор коммита, вернее его хэш. 

Права на файлы	Также, после успешного коммита показывается информация об уникальном коде конкретно этого добавления, о количестве добавленных файлов и числе изменений, о правах на файл. после слов create mode идет число, которое состоит из идентификатора типа файла: 100 - это файл, а также прав на исполнение-  644 неисполнимый файл, 755 исполнимый файл. Соответствует восьмеричной системе прав на файлы. Редактирование файла в исполнимый через chmod.

Просмотр авторов и коммитеров	"Просмотр авторов и коммитеров, есть разница между этими двумя сущностями, оба они участвуют в созданном коммите. Для того, чтобы указать автора иного человека, чем коммитер, необходимо использовать ключи для команды git commit, такие как --author и --date. Записать данные об авторе и коммитере можно в переменные окружения - GIT_AUTHOR_DATE	присвоение коммиту даты внесения изменений, GIT_AUTHOR_EMAIL	присвоение коммиту емейла автора, GIT_AUTHOR_NAME	присвоение коммиту имени автора, GIT_COMMITTER_DATE	присвоение коммиту даты внесения коммита, GIT_COMMITTER_EMAIL	присвоение коммиту емейла коммитера, GIT_COMMITTER_NAME	присвоение коммиту имени коммитера."

Добавление файлов и директорий	GIT не умеет работать с пустыми директориями, поэтому, чтобы закоммитить новую папку, необходимо сразу наполнить ее файлом. Можно даже скрытым типа .gitkeeper. В случае, если в рабочей  директории есть файлы или папки, которые не должны отслеживаться, то можно их убрать. Для этого используйте команду git reset HEAD. Можно просто создать файл .gitignore и внести в него папки для игнорирования, положив его в корневую папку. 

Хороший коммит	Комиты лучше делать атомарно, то есть по очереди, добавляя все отдельные значимые изменения по отдельности. Это позволяет отслеживать историю коммитов и реагировать на нее. Коммит должен быть консистентным, то есть законченным. Решающим один вопрос полноценно. Коммиты после можно отменять, изменять, делиться с коллегами, поэтому лучше не делать их оним блоком. Хорошие описания для коммитов, без точки в конце, пишется с большой буквой, уточнять с чем и через двоеточие что сделано. Далее описывается проблема и ее решение. Важно при работе в команде и для собственного возвращения к тем или иным этапам понимать почему и как было сделано то или иное действие.

Зачем нужен индекс	Зачем нужен Индекс? Для коммита только законченных файлов, в том числе частей файла, которые отвечают законченной разработке. для исполнения главого принципа коммитов - поэтапности и завершенности каждой части внедрена двухступенчатая система. Чтобы в общую зону разработки попадали только законченные результаты разработки. Git add позволяет добавлять в Индекс даже отдельные части одного документа. 

Коммиты без индексации	Как записать в репозиторий минуя индекс, для этого используем git commit -a, добавляя сразу и в индекс и в репозиторий. Как правило это работает с простыми изменениями, в том числе можно указать отдельный файл и закоммитить только его. . Когда это не получится - когда файл не отслеживается еще Индексом. 

Удаление и переименование файлов	Удаляя файл в рабочей директории, вам нужно добавить в индекс это изменение и закоммитить удаление. Также можно пользоваться командой rm просто и с ключом -r для директорий. Переименование файла равно удаление старого файла и создание нового файла, поэтому требует коммита обоих действий. 

Ветки	Ветки разработки нужны для взаимоизолированной работы над основным проектом, и, например, доработок, фич, релизов. Существуют тематические и релизные ветки, которые отличаются наполнением и способом взаимодействия. Существует как правило ветка Мастер, которая содержит основное развитие проекта. Отдельно могут создавать ветки, в которых идет разработка дополнительного функционала, который после его полной совместимости с основной версией можно добавить. Релизные ветки отличаются тем, что в линии мастер идет доработка функционала, а в ветки релиза - только доработка и шлифовка того функционала, который вошел в релиз. По сути - ветка это ссылка на конечный коммит, который отражает определенный этап разработки, но также содержит список всех предшествующих коммитов, которые привели к текущему состоянию. 

Создание и переключение веток	Все коммиты в ветках можно посмотреть по пути /git/refs/head/master, либо другое имя в зависимости от названия ветки.  Файл хранит список всех коммитов, но иногда ГИТ их пакует и переносит, поэтому тут может быть не вся информация. Поэтому лучше смотреть в терминале через git branch или git branch -v для вывода последнего коммита. При создании нового коммита всегда идет отслеживание текущего коммита, как родительского. Что дает возможность соединить информацию с последовательностью разработки. Новый коммит по умолчанию становится верхушкой разработки и от него будут стартовать последующие коммиты. Создание через команду branch и переключение через checkout. При переключениях между ветками каждая покажет только то состояние файлов, которое соответствует наиболее позднему коммиту в ветке. 

Команда чекаут	Команда checkout имеет свои особенности. При попытке переключения при незакоммиченых изменениях вызовет предупреждение GIT, но их можно игнорировать с -F, но тогда все незакоммиченные изменения удалятся. Так можно избавляться от неудачных экспериментов, в том числе откатываясь к последнему комиту текущей ветки. чекаут -f - и все будет удалено, вернее заменено состояниями файлов из текущей ветки. Для сохранения незаконченных изменений без коммита использовать git stash. GIT призван следить за изменениями на разных ветках так, чтобы они не ломали друг другу код. Незакоммиченные изменения не станут препятствием для смены ветки, если в репозитории хранятся одинаковые версии файлов. 

Ветки – Перенос незакоммиченных изменений	В случае, если при работе в ветке вы создали ряд изменений, но эти изменения незавершенные и для этой ветки они еще не должны быть внесены, то через checkout -b  можно создать сразу новую ветку и закоммитить в нее изменения, оставив начальную ветку нетронутой.

Ветки – Перенос веток "вручную"	Если коммиты сделаны не в той ветке, либо сделаны в основной, но незавершены и их нужно отнести на другую ветку. Сначала сделать запись в той ветке, в которой нужно, либо создать новую. а затем через -ф бранч вернуть на нужный коммит. 
Ветки – Состояние отделённой HEAD	При выборе команды checkout и номера коммита создается состояние отделенный Хеад. Находясь на коммите, который не является последним для любой из веток, мы имеем особый статус. С этого коммита можно запустить новую ветку, либо изменив или удалив здесь какие-либо данные - создастся новая ветка, у которой не будет названия и возвращаться к ней можно только по номеру коммита. Чтобы присоединить эти коммиты ветке нужно перейти на ветку и выбрать cherry-pick.

Ветки – Восстановление предыдущих версий файлов	При использовании команды git checkout с аргументом в виде названия файла можно восстановить предыдущую версию не всего проекта, а отдельного этого файла. Файл записывается сразу в индекс и при коммите станет актуальной именно эта версия. чтобы этого не произошло можно выполнить команду git reset и убрать файл из индекса. При одинаковых названиях ветки и файла гит сначала обращается к поиску ветки, если не находит - то к директории или файлу. Чтобы обратиться именно к файлу, перед названием стоит поставить --. 

Ветки – Просмотр истории и старых файлов, символы ~, ^, @, поиск с :/	Смотреть список коммитов git log, конкретные коммиты git show. Show можно использовать разные ключи чтобы смотреть коммиты с известными номерами или относительные пути, чтобы указать без номера на родительский и раньше коммиты. 

Ветки – Слияние веток "перемоткой"	Для слияния веток, добавления законченной разработки в одной ветке в другую. Переключаемся на ту, в которую будем добавлять. далее git merge, либо git checkout  -В, которые перенесут на актуальное состояние HEAD. В случае, если присвоение нового коммита ветке было неверным, вернуть все назад можно командой git branch -f &&& ORIG_HEAD. ORIG_HEAD - переменная, которая хранит идентификатор предыдущего коммита текущей ветки. Merge и checkout -B в некоторых случаях идентичны, но merge имеет больший функционал и потенциал. 

Ветки – Удаление веток	Удаление веток происходит через команду git branch -d, но с вниманием к тому, что могут быть удалены и коммиты, не объединенные с другими ветками.

Ветки – История переключений веток: лог ссылок reflog	Лог ссылок - всех действий во всех ветках находится в директории .git/logs/. Можно использовать команду git reflog для краткого вывода всей информации по отдельной ветке или HEAD. Включает информацию о коммитах, переключениях между ветвями разработки. Не включает информацию о создании веток, так как содержит только информацию о работе с HEAD. Рефлоги хранятся 90 дней, а если запись удалена, то только 30. Можно пересылать коммиты, но не рефлоги, они сохраняются только у пользователя. 

Удаление "лишних" файлов и незакоммиченных изменений	Мы можем откатывать состояния файлов в рабочей директории из Индекса и репозитория, но иногда бывает, что нужно удалить файлы, которых нет в финальной версии в репозитории и даже нет в отслеживаемых Индексом. Они все вторичны и не нужны. Для этого не подходит git reset --hard - жесткий ресет, который сбросит все изменения в отслеживаемых файлах, но подходит git clean -dxf.

Reset – Жесткий reset --hard: отмена изменений, удаление коммитов	Git reset позволяет откатить изменения истории, файлов, рабочей области, всех вместе или по отдельности на конкретное состояние коммита в репозитории. Используется для полной отмены последнего коммита и удаления незакоммиченных изменений.

Reset – Мягкий reset --soft: замена и объединение коммитов	Мягкий ресет позволяет устранить сложность с тем, что изменить коммит после его внесения невозможно, ни описание, ни автора, ни что-либо еще. Поэтому мы откатываем при помощи git reset --soft только последний коммит, а состояние рабочей директории коммитим правильно. 

Reset – Правка последнего коммита: commit --amend	Правки последнего и только последнего коммита в отличие от софт ресета могут быть осуществлены при помощи git commit --amend. Можно исправить что-то одно, остальное все оставить прежним и сделать верный коммит. 

Reset – Смешанный reset (без флагов), сравнение видов reset	При помощи команды git reset --mixed или по умолчанию просто git reset верхушка текущей ветки откатится на нужное число коммитов назад, индекс обновится согласно ей, но рабочая директория останется нетронутой. Если в индекс отправили преждевременно файлы, которые содержат изменения, не нужные на данный момент. Тогда без возврата по коммитам вызов команды git reset просто сотрет Индекс  и наполнит его состоянием файлов из репозитория. 

Reset – Таблица с действиями reset	В странице помощи к команде reset есть таблица, в которой наглядно демонстрируется влияние типов ресета на области файла

Просмотр – Сравнение коммитов, веток и не только: git diff	При вызове команды git diff мы можем сравнить состояние отдельных файлов или целых веток. Вывод команды покажет какие файлы сравнивает, какое контрольное значение у обоих, какое имя файла. Далее текстом, если большое число изменений, то несколькими блоками текста, показывается содержимое. Где красным показывается, какие строки нужно убрать, чтобы из первого файла сделать второй, а зеленым, какие строки нужно добавить для того же самого. Эта команда позволяет оценить разницу между состояниями Рабочей директории и Индекса или репозитория. Вызвав без ключей идет сравнение с Индексом. С аргументом HEAD - с репозиторием. Игнорируют неотслеживаемые файлы. При запуске коммита, можно использовать его с аргументом в таком виде git commit -v, тогда в редакторе сообщения для коммита покажутся изменения, которые сейчас коммитятся. Чтобы включить эту функцию на постоянной основе используйте git config --global commit.verbose true - команда запишет в конфиг постоянный вызов этого состояния. Также с ключом --name-only можно посмотреть список файлов, которые были изменены, чтобы потом выбрать конкретный и посмотреть его.

Просмотр – Вывод истории: git log, форматирование коммитов	Команда git log способна выводить информацию о коммитах в нужном виде и конструируется как угодно. Существует множество параметров, которые можно настроить. 
Просмотр – Диапазоны коммитов для git log и не только	Коммиты при просмотре через git log можно сортировать по веткам, например через --graph. Можно через поиск по git gui найти графические инструменты отрисовки веток, что даст возможность наглядно видеть при сложной и большой структуре веток. При использовании git log можно исключать ненужные коммиты через знак ^. 

Просмотр – Вывод git log коммитов, меняющих нужный файл	При задании команде git log имени файла, покажутся все коммиты, в которых менялся именно этот файл. 

Просмотр – Поиск в истории, фильтры для git log	Поиск по коммитам осуществляется через атрибут --grep, по умолчанию только в текущей ветке. Можно искать как одно из совпадений, так и соответствие всем сразу. Для поиска можно подключить регулярные выражения, которые заключаются в одиночные кавычки и содержат логические выражения или, и и прочие. Приняты pearl-подобные выражения, которые можно подключить постоянно добавляя к таким запросам ключ -P, а можно прописать сразу git config --global grep.patternType perl, и тогда все запросы grep будут считывать как регулярные выражения. Ключ -i отключает регистр. Есть более сложные поиски внутри файлов - это ключи -G и -L. Также есть функции поиска по автору, дате и прочим переменным.

Просмотр – Кто написал эту строку? git blame	Просмотр построчный файла с именем автора каждой строки, почти нет флагов. 

Слияние – "Истинное" слияние и разрешение конфликтов в git merge	Перед слиянием важно, чтобы статус был чистым. Данная команда git merge берет значения файлов в точке разделения двух веток и добавляет к ним все отличия, которые есть на последних коммитах обеих веток. Если будет ситуация, где одно и то же место одного файла изменены по-разному, то GIT спросит, какому изменению верить и взять в конечную версию. Чтобы выбрать, нужно запустить команду git checkout с аргументом в виде нужной ветки --ours или --theirs. При выборе флага --merge снова покажут конфликтную зону. Git reset --hard отменит слияние и очистит все незакоммиченные изменения. Вместо --hard использовать --merge - GIT оставит нетронутыми все файлы вне конфликта. Чтобы оставить оба составляющие файла, то просто отредактируйте его и внесите в индекс. После этого можете закоммитить изменения обычным способом и получите новый коммит, который будет содержать результаты слияния двух веток. 

Слияние – Коммит слияния, дальнейшие слияния	У полученного коммита есть ряд особенностей, он называется коммитом слияния и имеет двух родителей. Merge берет при слиянии информацию из MERGE_HEAD и добавляет как дополнительного родителя. Запуск команды git log -- oneline--all --graph покажет наглядно ветку слияния. А git show покажет последний коммит, как merge и с двумя родителями. Diff в этом случае покажет изменения относительно обоих родительских документов, соответственно это может быть как один + или -, так и сразу два, если дополнение писалось в момент слияния. Команда git diff позволяет посмотреть через HEAD^1 отличия от основного родителя, а HEAD^2 от дополнительного родителя. Добавляя несколько кареток переноситесь на столько прародителей назад. 

Слияние – Отмена слияния	Производится при помощи той же команды git reset --hard, которая просто удаляет новый коммит и возвращает состояние HEAD для текущей ветки на 1 шаг назад. 
Слияние – Семантические конфликты и их разрешение	Git сам стремится решить все конфликты, но если изменения происходят в разных частях файла, то может не заметить и пропустить. Такие конфликты семантические, ведь они конфликтуют по смыслу, а не месту в файле. Для ручного исправления такого конфликта нужно вызвать git merge &&& --no-commit, дальше подправить нужные исправления и завершить слияние, сделав git add, а затем и git commit или git merge --continue. 

Слияние – Полезный приём: сохранение веток с флагом --no-ff	При перемотке не всегда понятно, какие коммиты были на новой ветке, какие на старой. При возникновении ошибок сложно вернуться к предыдущей версии разработки. Для этого можно поставить ключ --no-ff, который запретит перемотку для слияния. Можно поставить настройку GIT git config merge.ff false - тогда перемотка будет запрещена всегда. 

Слияние – Создание коммита из ветки: merge --squash	В ситуации, когда результаты разработки нужны, но вся история разработки не нужна используется git merge --squash. В этом случае может произойти конфликт в Индексе, где сразу несколько записей об одном файле, но его можно исправить, подправив файл и проиндексировав изменения. Всегда создается новый коммит с одним родителем, а второй родитель не учитывается вовсе. 

Копирование коммитов – Копирование коммитов: cherry-pick	Иногда изменения в одной ветке нужно внести в другую ветку, но строго в одном или нескольких файлах, а не во всех сразу. Для этого применяется git cherry-pick. Эта команда берет разницу текущего коммита в ветке с предыдущим и вставляет его в другую ветку. В этом случае появятся два эквивалентных коммита. Добавление коммита можно прервать или отменить вовсе. Также можно не создавать коммит, а просто перезаписать в текущий при помощи команды git cherry-pick -n. 

Перемещение коммитов – Перебазирование вместо слияния: rebase	Использование команды rebase позволит скопировать все коммиты какой-то ветки к текущему состоянию другой ветки. Например при создании новой ветки началась параллельная разработка, но в главной ветке произошли ряд изменений и теперь важно, чтобы новая ветка их всех учитывала. Можно объединить ветки, но нам не нужно изменения второй ветки добавлять к первой. Этому используем git rebase, где первым коммитом второй ветки станет текущий коммит первой ветки со всем текущим состоянием файлов. Прекратить можно при помощи git rebase --abort. При возникновении ошибок GIT предложит исправить их, но можно остановить перенос, можно пропустить эту ошибку и перейти дальше. Отменить эту команду можно git reset.

Перемещение коммитов – Rebase и merge: сравнение подходов	Для выполнения задачи придания одной ветке изменений в другой можно использовать обе команды rebase и merge. При rebase - сильно упрощается история разработки. При merge могут создаваться много мусорных коммитов слияния. Однако, rebase плохо подходит если разработка ведется в ветке несколькими людьми, тогда может произойти ситуация, что один человек коммитит из старого состояния ветки, а другой из новой. Rebase при работе в онлайн или других людей - запрещены. Также при rebase создаются новые коммиты, которые могут при этом вообще не работать, так как не адаптивны с тем, что изменилось в мастер. 

Перемещение коммитов – Rebase с тестами, флаг -x	Для проверки корректности работы проекта после перебазирования можно запустить git rebase -x '&&& ', где &&& - проверочная команда, которую нужно запускать для проверки отсутствия ошибок. Если ошибок нет - то команда завершится. Вместо &&& обычно ставятся программы - тесты. 

Перемещение коммитов – Перенос части ветки, rebase --onto	При необходимости перенести только часть коммитов используется git rebase --onto &&&, где &&& - новая ветка для переноса, можно задать конкретный коммитов или выражение состояния.

Перемещение коммитов – Перебазирование слияний, --rebase-merges	При перебазировании всегда пропускаются коммиты слияния, поэтому, если в них были внесены изменения, то их не будет на новой ветке. Для переноса коммитов слияния используется --rebase-merges.

Перемещение коммитов – Интерактивное перебазирование, rebase -i	При запуске git rebase -i  выдастся текстовый редактор, в котором можно указать какие коммиты ветки, которую планируется перебазировать, каким действиям будут подвержены - коммиты можно пропустить, скопировать, объединить со всеми описаниями или без них, изменить описание коммита. Это позволяет сохранить ветку перед публикацией для удобного чтения и использования другими людьми. При выполнении действий внутри такого перебазирования можно после любого шага оценить, что будет следующее  и что вообще еще нужно сделать. Для этого используется команда git rebase -edit-todo. командой git rebase -i  можно не просто создавать новые ветки, но редактировать текущую, просто указав начало ветки, с которого нужно применить изменения. И делать все, что позволяет эта команда. Перебазирование начинается только с того коммита, в котором вносятся изменения. 

Перемещение коммитов – Исправляем коммит посередине ветки: autosquash	Можно выбрать коммит любой, даже посредине ветки и изменить его посредством git commit -a --fixup=&&&, где &&& название коммита. После запуска интерактивного перебазирования с аргументом --autosquash или указанием постоянного применения этого аргумента в в виде git config --global rebase.autoSquash true, коммит с идентификатором fixup объединится с коммитом, который он менял. 

Отмена коммитов через revert – Обратные коммиты, revert	Позволяет создать новый коммит, который отменяет изменения указанного коммита. Указать можно как один коммит, так и несколько, например диапазон. Имеет все ключи, как и у cherry-pick. 

Отмена коммитов через revert – Отмена слияния через revert	При обращении коммитов слияния нужно указывать специальный флаг и имя нужной ветки. Если нужно будет после доработок вернуть изменения в ветке основной, то можно либо revert на коммит отмены слияния, либо cherry-pick коммит слияния, либо вручную коммиты, которых не хватает в основной ветке. Предпочтительнее делать отмену отмены и дополнять изменениями из ветки присоединения. 

Отмена коммитов через revert – Повторное слияние с rebase	В случае, если был отменен коммит слияния, ошибки исправлены и разработке требуется снова слить основную ветку и ветку разработку, то можно просто сделать rebase, а потом слить ветки. Для повторного разрешения конфликтов можно использовать сервис rerere, который настраивается через git config rerere.enabled true. Его можно запустить из места его установки с ключом --all, тогда он выучит все конфликты, которые были, и начнет запоминать те, которые будут. И еще один способ избавиться от ненужных слияний, это сделать rebase на то же место, делается с ключом --no-ff, что позволит создать копию ветки и избавиться от слияния. 

Pull request или Merge request - специальные запросы на гитхаб, которые позволяют добавлять в главную ветку только те изменения, которые одобрены командой или тимлидом. Делается в самом Github с указанием откуда и куда планируется слияние и описание, что изменено и что смотреть. Коллеги могут откомментировать строки кода, чтобы помочь вам его улучшить или исправить. Если использовать кнопку Merge в IDE - интегрированной среде разработки, то можно быстро найти и исправить конфликты при слиянии веток, не по одной, а все разом конфликты. Показывает три состояния файла - по бокам из двух веток, в центре финал, в который можно добавить изменение из одной, ни из одной, из обеих и даже совсем не из веток. а написать заново содержание. 

### Команды для управления Git

- git config - показывает список конфигураций GIT в системе.
    - git config --list - показывает для проверки все настройки конфигураций на всех уровнях. 
    - git config pretty.&&& format:ХХХ - создание собственного формата вывода git log и прочих команд сбора информации, которому задается имя &&&, а вместо ХХХ пишутся корректировки, как формат будет выглядеть. После этого можно использовать следующую команду 
    - git config format.pretty &&& - она установит этот формат для всех выводов. 
    - git config log.date позволяет выбрать формат даты, который будет использоваться при выводах команд git. 
    - git config merge.ff false - запрет слияния перемоткой для всех слияний. Вернуть можно подставив true. Если указать git config branch.&&&.**, то GIT создаст правило ** для ветки &&&, которое будет действовать только тут, например git config branch.master.mergeoptions '--no-ff' - запрет перемотки при слиянии. Help для данной команды также содержит информацию о цветах, которые можно использовать при работе с git.

- git commit - запись в репозиторий изменений проекта
    - git commit --author='&&&<**>' - присвоение имени автора при коммите, где &&& - имя, а ** - емейл. 
    - git commit --date='&&&' - присвоение даты автора при коммите, где &&& - дата внесения изменений. 
    - git commit -m ' ' - позволяет записать в репозиторий без вывода текстового редактора для написания комментария изменения. git commit --amend - позволяет одновременно откатить последний коммит и создать новый с обновлениями из рабочей директории. 
    - git commit --reset-author - делает автором в новом коммите коммитера. 
    - git commit --no-edit - отменяет вызов редактора и берет сообщение из прошлого коммита. 
    - git commit -v - позволяет при написании текста коммита видеть изменения, которые коммитятся открывает редактор, в котором можно написать причины и особенности новых изменений, которые добавляются в проект, а также из индекса записывает в репозиторий файлы.

- git show - показ подробной информации о коммите 
    - git show &&&~ - выводит подробную информацию о родительском коммите коммита с номером &&& или из ветки &&&, или просто на 1 шаг назад. чем больше тильд, тем больше шагов назад. 
    - git show &&&~? выводит подробную информацию о коммите предыдущем текущему коммиту с номером &&& или из ветки &&& на число шагов равное ?. git show --quiet - выводит сокращенную информацию о коммите, только автор, дата и описание. 
    - git show &&&~?: ** выводит подробную информацию о коммите предыдущем текущему коммиту с номером &&& или из ветки &&& на число шагов равное ?. но показывает состояние только файла **. git show :/** показывает информацию о файле в самом свежем коммите, в котором содержатся слова **. " git show &&& - выводит подробную информацию о коммите с номером &&& или из ветки &&&, указав идентификатор, или его начало, но не меньше 4 символов. Если не указывать &&&, то покажется информация о последнем коммите из Head.

- git status - проверяет состояние файлов из текущей директории относительно GIT.
 
- git add - добавление в Индекса GIT
    - git add -p - &&& - добавление файлов в Индекс частями, файл вместо &&&. Выведется меню выбора, какие из изменений добавлять, а какие нет. 
    - git add -f &&& - индексация файла внутри игнорируемой директории, путь до файла прописывается &&&. 
    - git add -A - добавление в индексирование все найденные изменения во всех директория, начиная с корня проекта.
    - git add &&& - добавление конкретного файла &&& в Индекс GIT, git add . - добавление в индексирование все найденные изменения в той директории, в которой находимся
 
- git config &&& - изменение конфигураций git config user.email &&& - установка конфигурации email пользователя GIT. 
    - git config user.name &&& - установка конфигурации имени пользователя GIT. 
    - git config core.editor &&& - установка конкретной программы для работы с GIT. 
    - git config alias.&&& '**' объединение в алиас на глобальном уровне в конфигурации, где &&& - название алиаса, а после него идет описание команды в ' ' и помечено **. 
    - git config --unset &&& - для стирания конкретных параметров конфигурации GIT, убирает указанную информацию из конфигурационного файла. 
    - git config --remove-section &&& - удаляет полностью записи в конфигурационном файле о выбранном пользователе &&&. С использование ключа --global все эти изменения коснутся глобального уровня конфигураций GIT. 
    - git config --global core.excludesFile ~/.gitignore - добавление на глобальном уровне файла исключений из индексации ГИТ. 
    - git config rebase.missingCommitsCheck warn/error - включает оповещения при ошибках при rebase, которые затрагивают потерю коммитов. 
    - git config rerere.enabled true - включает сервис подстановку старых решений конфликтов.
 
- git reset -  возврат предыдущих значений
    - git reset &&& - убирает файл &&& из индекса, и он не попадет в следующий коммит. 
    - git reset HEAD - сброс индексации определенного каталога. 
    - git reset --hard '@~' - обновляет файлы, историю, рабочую область на 1 шаг назад по текущей ветке разработки. 
    - git reset --soft '@~' - мягкий ресет, который вернет только историю, но не затронет файлы и рабочую директорию, они останутся теми же, которые были до этой команды. 
    - git reset --mixed - возвращает ветку на указанный коммит и присваивает индексу состояние на момент этого коммита. можно указать конкретный путь, тогда сбросится состояние конкретного файла или директории. добавление файла в список исключений для отслеживания GIT или в общем работает с откатом чего-либо. Применяется синтаксис ~, которая значит предыдущее состояние, предыдущий коммит, например. а ~3 - за 3 коммита до этого.
 
- git commit -am -  запись в репозиторий напрямую, минуя индекс, для легких и простых изменения файлов, которые уже проиндексированы, без вывода дополнительного окна для комментария изменения 
    - git commit --all или git commit -a - запись в репозиторий напрямую, минуя индекс, для легких и простых изменений файлов, которые уже проиндексированы. 
    - git commit -m - запись в репозиторий без вывода дополнительного окна для комментария изменения. 
    - git commit -a --fixup=&&& - где &&& название коммита, а команда позволит создать новый коммит, в котором есть изменения конкретного этого коммита.

- git rm - удаление файла из рабочей директории и из Индекса
    - git rm --cashed - удаление из индекса файла, но сохранение его в рабочем каталоге, 
    - git rm -r - удаление из рабочей директории и из индекса директории, 
    - git rm -r --cashed - удаление из индекса директории, но сохранение ее в рабочем каталоге. 
    - git rm -f - позволяет принудительно удалить файлы, которые не сохранены в репозитории.

- git mv - переименование файла в рабочей директории и репозитории для переименования файла из рабочей директории в индексе и сразу в репозитории. пишутся подряд через пробел старое название файла и новое название файла
 
- git branch - список текущих веток разработки
    - git branch -v - список текущих веток разработки с указанием на последний коммит. 
    - git branch --merged - покажет объединенные ветки. git branch --no-merged - покажет необъединенные ветки.
    - git branch &&& создание новой ветки разработки git branch -f &&& ??? - позволяет создать новую ветку с названием &&& начиная с какого-то коммита с номером ???. либо ветку &&& откатить до коммита ???. В общем делает финальным коммитом указанной ветки указанный коммит. Либо указав название другой ветки в качестве второго аргумента можно перенести выбранную ветку на ее последний коммит. 
    - git branch -f &&& ORIG_HEAD - возврат текущей ветки &&& на предыдущее состояние, на предыдущий коммит, либо HEAD@{&&&} - в момент коммита записанного в рефлоге под номером &&&. создание новой ветки разработки с именем &&& на базе последнего комита

- git checkout - смена текущих коммита или ветки 
    - git checkout -b - создание новой ветки разработки на базе последнего комита и переключение на нее сразу. 
    - git checkout -f - принудительный переход на новую ветку даже с потерей всех созданных изменений в файлах. 
    - git checkout -B &&& ** - создание новой ветки разработки с именем &&& на базе комита с номером ** и переключение на ветку &&&, либо перенос ветки с названием &&& на нужный коммит. 
    - git checkout &&& ** - способен взять версии конкретного файла **, перечня файлов ** через пробел или целой папки ** с определенного коммита &&&, автоматически добавляя в индекс и обновляя там его. Если вместо &&& стоит HEAD, то из репозитория головной ветки забирает нужный файл или файлы. Если указать без пути &&&, то просто из Индекса возьмет. 
    - git checkout @{-1} - возврат на ветку, бывшую предыдущей до перехода на текущую. вместо 1 подставить другие значения и тогда перекинет на столько переходов назад, сколько будет число.
    - git checkout - - возврат на ветку, бывшую предыдущей до перехода на текущую. git checkout &&& - переключение на ветку &&& либо на любой коммит с номером &&&.
 
- git stash - сохранение незакомиченных изменений в гит, чтобы не потерять при смене ветки
    - git stash pop - возвращение незакомиченных изменений из специальной области GIT, чтобы работать с ними далее, развернуть их можно и на другой ветке, не той, где изменения сохранялись. создание специальной области хранения информации об изменениях в файле, которые не идут еще в Индекс и Репозиторий, но уже можно к ним вернуться после возврата на ветку.
 
- git cherry-pick - передача коммита или серии коммитов текущей ветке 
    - git cherry-pick --abort - прерывает текущее добавление коммита и сбрасываем. 
    - git cherry-pick --continue - продолжает добавление коммита, 
    - git cherry-pick --quit - останавливает добавление до иных действий. 
    - git cherry-pick -n - придает текущей ветке значение любого коммита как более раннего из этой ветки так и из другой ветки, но без коммита. позволяет передать указанные коммиты текущей ветке, чтобы избавить от брошенных коммитов вне ветвей разработки. Так как GIt со временем их удалит. Основная задача - передача коммитов, в которых исправлены какие-то недочеты ветке, в которой еще эти ошибки есть. То есть возможность взять исправление ошибки из другой ветки или старое состояние файла, которое не вело к ошибке и применить только его. Можно давать имя коммита, несколько коммитов через пробел или какой-то промежуток.
 
- git log - выводит список коммитов
    - git log &&& --oneline - вывод списка коммитов из ветки &&& по строке на каждый коммит. 
    - git log --oneline - вывод списка коммитов, где на каждый коммит предусмотрена одна строка. 
    - git log -p - выведет все коммиты с показом изменений в них. 
    - git log --graph - сортирует коммиты по веткам. 
    - git log --all - выводит дерево из всех коммитов, достижимых из всех ссылок. 
    - git log &&&1..&&&2 --boundary выведет список коммитов с момента отделения ветки &&&2 от ветки &&&1, последний ключ покажет также коммит, с которого началось отделение. 
    - git log --grep - для поиска по коммитам по текущей ветке конкретных слов, вставляя несколько раз --grep со словом, можно искать все коммиты, в которых есть либо то, либо другое слово. 
    - git log --grep& --grep&& --all-match - ищет коммиты, в которых есть сразу и &, и && слова. git log -G&&& -p - поиск по самим файлам слова &&& с показом содержимого файла. 
    - git log -L - позволяет задать в качестве аргумента начало и конец диапазона, в котором будут отслеживаться изменения. 
    - git log --author=&&& - ищет все коммиты с автором &&&, Также подставляются --committer (поиск по коммитерам) или --before (по коммитам до определенной даты или времени). 
    - git log --first-parent - покажет изменения и коммиты только по ветке первого родителя слияния. последовательно выводит список всех коммитов с информацией об авторе, дате. комментарии, полном идентификаторе, может выведен с ключом --oneline, тогда выведется только идентификатор, точка прикрепления ветки, комментарий коммита. При указании в качестве аргумента названия ветки, выведет только коммиты этой ветки. Можно выбирать нужные коммиты, фильтровать, искать по ним. Можно задавать разные параметры через --pretty=&&&, вместо &&& уже подставляются те или иные способы выведения информации с аргументами. Если задать --pretty=format' ', то в кавычках через пробел можно указать разные значения, какие в каком порядке вы хотите видеть.
 
- git merge - перенос результатов одной ветки в другую
    - git merge --log=& - проводит слияние, а сообщением нового коммита делает все сообщения предыдущих & коммитов, собрав описание из предыдущих сообщений. 
    - git merge --ff - создание слияние при помощи перемотки. 
    - git merge --squash - объединение веток путем простого переноса изменений в основную ветку. В этом случае происходит не слияние, а скорее возвратная запись. добавляет текущей ветке все коммиты и изменения ветки &&&, делая последний коммит ветки &&& последним коммитом текущей ветки.
 
- git branch -d - удаление ветки разработки
    - git branch -D &&& - удаление ветки с названием &&&, даже при наличии коммитов, не объединенных с другими ветками, такие коммиты со временем будут удалены но только при отсутствии коммитов, не объединенных с другими ветками
 
- git reflog - вывод изменений на ветке HEAD
    - git reflog &&& - вывод информации об изменениях на ветке &&&. 
    - git reflog &&& --date=iso - выведет рефлог с добавлением информации о дате изменения.
 
- git init - создание GIT-проекта в папке проекта с базами данных и настройками.
 
- git clone - клонирует облачный репозиторий.

- git clean - удаление в рабочей директории всех неотслеживаемых файлов 
    - git clean -d - для удаления директорий, 
    - git clean -x - удаление игнорируемых файлов через гитигнор, 
    - git clean -f - подтверждение необходимости удаления.
 
- git restore - возвращение файла из Индекса, стирание его оттуда
 
- git diff - сравнение коммитов или файлов
    - git diff &&&1...&&&2 - &&&1 и &&&2 - названия веток, с тремя точками покажет изменения в первой ветке с момента расхождения со второй веткой. 
    - git diff HEAD - покажет изменения в данный момент относительно последнего коммита. 
    - git diff --cashed - покажет изменения в Индексе, которые еще не внесены в репозиторий. 
    - git diff --name-only можно посмотреть список файлов, которые были изменены, чтобы потом выбрать конкретный и посмотреть его. 
    - git diff -U& - покажет только & строк вокруг измененных строк, по умолчанию стоит 3. выдает отдельными блоками различия между ветками, конкретными файлами в разных коммитах. Отдельный блок - содержимое отдельного файла, которое отличается от содержимого аналогичного файла. Синтаксис может быть git diff ветка1 ветка2 или git diff ветка1..ветка2 .
 
- git blame - вывод информации о строках файла с именем автора каждой
 
- git merge-base - показывает коммит, который стал базой для развертывания другой ветки
 
- git rebase - позволяет изменить родительский коммит для целой ветки, приняв всю разницу между прежним и нынешним состоянием родительского коммита. 
    - git rebase --abort - прекращает перенос ветки, удаляет новые коммиты, возвращает HEAD. 
    - git rebase -x '&&&'- запуск дополнительных команд &&&, как правило тестов, которые проверят ошибки при переносе веток. 
    - git rebase --onto &&& - позволяет выставить состояние ветки или конкретный коммит, до которых нужно перенести ветку в иное место. git rebase --rebase-merges - перебазирование ветки вместе с коммитами слияния с другими ветками, но без коммитов этих других веток. 
    - git rebase -i - покажет в текстовом редакторе набор команд, которые планируются для улучшения внешнего вида ветки, то есть описания коммитов. опасная, так как может создать ветку с ошибками, может помешать другим людям, которые тоже работают над этой веткой. Но позволяет быстро интегрировать изменения одной ветки в другую.

- git push - передача в удаленный репозиторий изменений, сделанных в рабочей директории
    - git push --set-upstream origin &&& - где &&& название новой ветки. 
    - git push --delete origin - удаляет папку в репозитории, если она удалена локально.
 
- git pull - забор из удаленного репозитория изменений, которых нет в рабочей директории
 
- git revert - создает новый коммит с отменой предыдущих изменений
    - git revert -m &&& - создает новый коммит, отменяя изменения в коммите слияния по сравнению с указанной &&& веткой. более безопасно, чем git reset, так как не удаляет коммиты, может отменить изменения в любом коммите в истории. 

# Управление данными через Redis
Redis - резидентная система управления базами данных класса NoSQL с доступным исходным кодом, работающая со структурами данных типа «ключ — значение». Для установки достаточно скачать при помощи пакетного менеджера. 

Далее управление идет через инструмент командной строки Redis-cli для передачи информации на сам Redis Server. 

Для записи строки используется синтаксис SET aaa "bbb" - где aaa - имя строки, а bbb - значение строки. Далее GET aaa "bbb" для получения значения строки, а DEL aaa "bbb" - для удаления строки. Указав KEYS * можно посмотреть значение всех записанных строк. Устанавливать значение строки можно не только текстовое в кавычках, но и цифровое без кавычек. С цифровыми значениями можно использовать операции вычисления. 

Строкой может быть массив данных в формате списка. Добавлять можно значения слева и справа командами LPUSH и RPUSH. LRANGE позволит посмотреть конкретный список в заданных значениях. LPOP показывает и удаляет элемент, LLEN - показывает длину списка. LPUSH - для переноса значений из одной таблицы в другую. 

Позволяет работать с хеш-таблицами, создавая через HSET, указывая имена столбцов, через HGET можно получать конкретные значения, или через HMGET списки значений. Команда FLUSHALL удалит все записи из системы. Записи создаются в Redis без ограничения времени жизни и доступны даже после перезапуска системы. 

Нужна прежде всего для сокращения скорости выдачи ответов при обращении пользователей на высоконагруженные системы. 

# Курс по Linux. "Подготовительный курс Linux" от Андрея Буранова, OTUS
### Операционная система - общие сведения
- 0.0.	Введение
- 1.1.	Для чего нужна ОС
- 1.2.	Первая ОС . История Multics
- 1.3.	MS-DOS
- 1.4	Ядро ОС
- 1.5	Кольца защиты и современные ОС
- 1.6	Итоги
### UNIX
- 2.1	История создания
- 2.2	Философия (всё есть файлы)
- 2.3	Стандарт POSIX
- 2.4	Варианты UNIX
- 2.5	Итоги
### Linux
- 3.1	Структура каталогов
- 3.2	Как устанавливается ПО в Linux
- 3.3	Версии Linux
- 3.4	Сложности на пути изучения Linux
### Простые команды
- 4.1	ls - Посмотреть список файлов в каталоге
- 4.2	touch - Создать файл
- 4.3	mkdir - Создать директорию
- 4.4	cd - Сменить текущую директорию
- 4.5	rm - Удалить файл
- 4.6	rmdir - Удалить директорию
- 4.7	cp - Копировать файл или директорию
- 4.8	mv - Переместить файл или директорию
- 4.9	type 
- 4.10	whereis -Узнать внутренняя или внешняя команда
- 4.11	who - Кто сейчас работает на сервере
- 4.12	man - Страница руководства
- 4.13	итоги
### Пользователи
- 5.1	Идентификация пользователя (UID)
- 5.2	root и все остальные
- 5.3	etcpasswd
- 5.4	etcgroup
- 5.5	etcshadow
- 5.6	Права на файлы в Linux
- 5.7	chmod
- 5.8	Файловые системы и inode
- 5.9	Для чего нужны каталоги
- 5.10	HardLink и SoftLink
- 5.11	Итоги
### Работа с файлами
- 6.1	grep
- 6.2	head
- 6.3	tail
- 6.4	more и less
- 6.5	Итоги
### Работа с потоками
- 7.0	Работа с потоками
- 7.1	Перенаправление в файл
- 7.2	Порядок выполнения команды в bash
- 7.3	Перенаправление в STDIN другой команды
- 7.4	tee
- 7.5	потоки и указатели
- 7.6	Итоги
### Логические операции
- 8.1	Код возврата
- 8.2	и
- 8.3	или
- 8.4	не имеет значения
- 8.5	Итоги
### Монтирование
- 9.1 где мои диски
- 9.2 Монтирование
- 9.3 итоги
### Установка ПО
- 10.1, 10.2, 10.3 rpm и yum
- 10.4 список файлов в пакете
- 10.5 Поиск пакета по файлу
- 10.6 список установленных пакетов
- 10.7 итоги
### Процессы
- 11.1 жизненный цикл процесса
- 11.2 PID, PPID
- 11.3 владелец процесса
- 11.4 демон
- 11.5 kill
- 11.6.1 top - Load Average
- 11.6.2 top - Cpu (sy, us, ni, id, wa, hi, si, st)
- 11.7.1 ps -efl
- 11.7.2 работа в консоли
- 11.8 итоги
### Сеть
- 12.1 ip a
- 12.2 ip r
- 12.3 etcresolv.conf
- 12.4 ss -tnlp
- 12.5 итоги
### Системы инициализации
- 13.1 MBR, GRUB, Kernel
- 13.2 SysV, upstart, systemd
- 13.3 итого
- Итоги курса


# Курс по Git

1.1	Что такое Git
2.1	Создание репозитория
2.2	Добавление файлов и индексация
2.3	Права на файлы
2.4	Просмотр авторов и коммитеров
2.5	Добавление файлов и директорий
2.6	Хороший коммит
2.7	Зачем нужен индекс
2.8	Коммиты биз индексации
2.9	Удаление и переименование файлов
3.1	Ветки
3.2	Создание и переключение веток
3.3	Команда чекаут
3.4	Ветки – Перенос незакоммиченных изменений
3.5	Ветки – Перенос веток "вручную"
3.6	Ветки – Состояние отделённой HEAD
3.7	Ветки – Восстановление предыдущих версий файлов
3.8	Ветки – Просмотр истории и старых файлов, символы ~, ^, @, поиск с :/
3.9	Ветки – Слияние веток "перемоткой"
3.10 Ветки – Удаление веток
3.11 Ветки – История переключений веток: лог ссылок reflog
4.1	Удаление "лишних" файлов и незакоммиченных изменений
5.1	Reset – Жесткий reset --hard: отмена изменений, удаление коммитов
5.2	Reset – Мягкий reset --soft: замена и объединение коммитов
5.3	Reset – Правка последнего коммита: commit --amend
5.4	Reset – Смешанный reset (без флагов), сравнение видов reset
5.5	Reset – Таблица с действиями reset
6.1	Просмотр – Сравнение коммитов, веток и не только: git diff
6.2	Просмотр – Вывод истории: git log, форматирование коммитов
6.3	Просмотр – Диапазоны коммитов для git log и не только
6.4	Просмотр – Вывод git log коммитов, меняющих нужный файл
6.5	Просмотр – Поиск в истории, фильтры для git log
6.6	Просмотр – Кто написал эту строку? git blame
7.1	Слияние – "Истинное" слияние и разрешение конфликтов в git merge
7.2	Слияние – Коммит слияния, дальнейшие слияния
7.3	Слияние – Отмена слияния
7.4	Слияние – Семантические конфликты и их разрешение
7.5	Слияние – Полезный приём: сохранение веток с флагом --no-ff
7.6	Слияние – Создание коммита из ветки: merge --squash
8.1	Копирование коммитов – Копирование коммитов: cherry-pick
9.1	Перемещение коммитов – Перебазирование вместо слияния: rebase
9.2	Перемещение коммитов – Rebase и merge: сравнение подходов
9.3	Перемещение коммитов – Rebase с тестами, флаг -x
9.4	Перемещение коммитов – Перенос части ветки, rebase --onto
9.5	Перемещение коммитов – Перебазирование слияний, --rebase-merges
9.6	Перемещение коммитов – Интерактивное перебазирование, rebase -i
9.7	Перемещение коммитов – Исправляем коммит посередине ветки: autosquash
10.1 Отмена коммитов через revert – Обратные коммиты, revert
10.2 Отмена коммитов через revert – Отмена слияния через revert
10.3 Отмена коммитов через revert – Повторное слияние с rebase