# Development Operations или DevOps  
администратор системы, инженер, который синхронизирует этапы создания программного продукта и отвечает за автоматизацию задач, связанных с настройкой и развертыванием приложений. Использует системы управления конфигурациями, решения виртуализации и облачные инструменты для балансировки ресурсов. Создание пайплайнов - автоматизированных последовательностей этапов, выполняемых для доставки приложения от команды разработчиков до конечного пользователя. Первые шаги для Линукс инженера: Устройство компьютера, Устройство Linux, Файловая система, Работа с BASH, Сети и сетевой стек. 

# 1. Для чего нужны ОС - операционные системы. 
При появление компьютеров и возникновении потребности в распределении  времени пользователей. С появлением файловой системы, динамического связывания, сегментно-страничной виртуальной памяти появилась и первая операционная система Multics. 
Она исполняет запросы команд на доступ данных, на ввод и вывод, выделение и освобождение памяти, загрузку программ в оперативную память и доступ к перифирийным устройствам. Управление оперативной памятью - она хранит и удаляет данные. Управление доступом к энергонезависимым носителям: жесткий диск, оптические диски. ОС организованны в той или иной файловой системе, обеспечивают пользовательский интерфейс, сохраняет ошибки. 
MS-DOS	Появился для работы на компьютерах PC IBM, имеет 3 основных компонента: io.sys - операционная система Дос, MSDOS.SYS  - обработка прерываний, COMMAND.COM - интерфейс командной строки. Вариативными являются CONFIG.SYS - конфигурация системы и загрузка драйверов. AUTOEXEC.BAT - стартовый пакетный файл при запуске. 

Типы ОС  по ядру ОС:
- Безядерные ОС позволяют программа напрямую обращаться к оборудованию. зачастую занимая один и тот же слот памяти. 
- В ядерных ос программы обращаются к ядру, которое выдает разрешенные потоки к оборудованию, тем самым структурируя запросы програм. ОС на ядре при переносе на другую архитектуру достаточно переписать только ядро. но не все программы. 

Каждое приложение имеет свое окружение, работают независимо, имеют свои доступы. Архитектура ядра: микро, монолит, гибрид. Различие - где работают драйвера, которые обеспечивают работу оборудования.
- Монолитные - его драйвера работают в пространстве ядра (UNIX, LINUX, FREE BSD), ошибка в одном драйвере вызовет ошибку вовсем ядре. понижает отказоустойчивость, но повышает скорость работы. 
- Микро - драйвера работают в отдельных пространствах и ядро обращается к каждому из них при необходимости (AIX, QNX, Minix), более стабильное, но медленнее, так как как процессор переключает контекст между разными программами.  
- Гибриды - (Windows, ReactOS, NeyWare) - можно спустить в пространство ядра нужные службы, а остальные в подпространства программ. 

Типы ОС по отношению к пользователям: 1. однопользовательские и однозадачные (в один момент - одна программа, только один тип пользователей, отсутствует разграничение доступов до своих ресурсов) 2. однопользовательская и многозадачная (в один момент может выполняться несколько программ, но все еще присутствует только один тип пользователей) 3. многопользовательские и многозадачные (в единицу времени может исполняться несколько программ, имеется механизм ограничения доступа до ресурса)

Кольца защиты и современные ОС.	Кольца защиты разделяют доступы на 4 кольца, что позволяет на аппаратном уровне разграничить опасность влияния программ, повышая отказоустойчивость. Есть три типа ресурса компьютера - память, командные инструкции и порты ввода/вывода. При переключение колец тратится очень много времени и ресурсов компьютера. Поэтому в современных ОС мы работаем почти всегда в кольце 3 - пользовательском кольце, а при необходимости установки драйверов или изменении ядра ОС - в кольце 0 - кольце операционной системы. Только на архитектуре х86 4 кольца защиты, на остальных - только 2, поэтому операционки и программы подстроены всегда под 2 кольца - пользователя и ядра. 
  
# 2.  История создания	и основы Линукс. 
Он взял принципы Юникс. который был разработан для 18ти битных компьютеров. UNIX создан Кеном Томпсоном и Деннисом Ритчи, создателем языка С, на котором написаны в том числе МакОС и Виндоус. Следы его работы во всех компьютерах. Задал стандарт всей ИТ отрасли. Написана на ассемблере, в 1975 переписана на языке С. Начало компьютерной эры с 1970 года. Юникс - основа для всех последующих ОС. Для каких-то напрямую, для каких-то в какой-то части.   
  
Философия (всё есть файлы)	
- Нет никаких дисков. нет поддержки структурированных файлов ядром ОС. переменные окружения. клонирование текущего процесса со всем состоянием. Все файлы сходятся в одну точку - руут. система файлов в значении структуры каталогов операционной системы - древовидная. 
- Файл - поименованная область данных на диске. 
- В каталоге /dev располагается перечень блочных устройств, которые являются файлами, аналогичными дискам. Если название диска представляет собой только буквы, то это физический диск. Если в нем присутствуют цифры - то это логический диск, выделенный на физическом диске.  Virtual File System позволяет работать с физическими дисками через единую систему, не смотря на различия в файловых системах дисков. VFS дает единообразный доступ к файловым системам любым клиентским приложениям. Интерфес между ядром ОС и файловой системой конкретного диска. Чтобы обращаться к конкретным дискам не нужны специальные запросы, только драйверы переводчики с VFS на язык диска. 
- Нет устройств, есть файлы, связанные с устройством. Жесткий диск. порты, подключение к веб, каталоги; все это - в формате файлов. Файл - поток байтов, нет разрешений. 
Расширение в название только для удобства пользователя, чтобы понимать - исполняемый или неисполняемый файл перед нами. 
- Интерпритаторы команд различны, обычная программа - оболочка.  Командных интерпритаторов много - shel, bash, ksh, csh  и другие. просто приложение, не является частью ядра системы. будет выполнять то, что мы ей будет вводить. 
-  Имя файла может содержать 255 символов, расширение не важно, его не существует, есть типы и аттрибуты файлов. Если имя начинается с точки, то этот файл будет скрыт и не показываться при обычных запросах
- Конфигурационный файл - текстовый файл, который описывает параметры запуска приложения. В Юникс очень большой, так как содержит очень много комменатриев. Полный перечень действий, параметров и результатов. 
- Атомарные команды для конкретных действий. 
- Юникс проприетарная система - исходные коды недоступны общественности. Узкие и мощные отрасли: Банки, Биржи, Диспетчерские центры, космические полеты. Не позволяет делать системы. Более стабилен, чем Интел. На всех суперкомпьютерах стоят Линукс. 
  
Философия (делайте хорошо): 
- пишите хорошие программы, которые делают что-то одно; 
- пишите программы, которые хорошо работают вместе; 
- пишите программы, которые поддерживают текст, так как это универсальный интерфейс. 
  
Стандарт POSIX - В мире Unix есть стандарт Posix, Посикс - язык запросов программ к ядру ОС, и ядра ОС к оборудованию. Стандартная для всех ОС составляющая - единый язык обращения к ядру.  Программы пишут под ОС, а не под компьютер. У разных ос разные языки общения с программами. Каждая ОС имеет интерфейс общения с ядром. Посикс - набор стандартов, описывающих интерфейс между ОС Unix и прикладной программой. Создан для обеспечения совместимости программ на различных ОС, использующих его стандарты и переносимости приклодных программ на уровне исходного кода. Переводит с языка исходного кода - С на язык машин - бинарный код. Унификация интерфейсов взаимодействия во всех ОС такого типа. Сохраняет обратную совместимость с теми версиями, что были ранее. Находится в пользовательском пространстве. Стандарты Posix описывают системный интерфейс, командный интерпреттор, утилиты. 

Варианты UNIX.	Линукс лидирует на рынке серверов. Юникс используется на мощных промышленных компьютерах:
- ХП Супердом, который способен иметь 4 ТБ оперативной памяти, 128 ядер. Ни одна Интел система с таким не справится. Проблема - один блок, антитенденция - сейчас разбитие на много малых серверов. Без выключения можно сменить все, работает безпрерывно несколько 15-20 лет. 
- AIX на IBM power system.
- Solaris от Oracle. на архитектуре Sparc64, способные масштабироваться до 256 ядер.

# 3. Структура каталогов Линукс.
строгая иерархическая структура. все ветки ведутся от root, который является корневым, главным. в нем содержится каталоги 
- bin (утилиты для однопользовательского режима, двоичные файлы и программы для загрузки и функционирования системы), 
- boot (образ начального диска с драйверами для загрузки и сам загрузчик, файлы для загрузки ОС, для запуска и ядро Linux), 
    - /boot/grub/grub.conf - настройка загрузчика.
    - /boot/grub/menu.lst - настройка загрузчика. 
    - /boot/vmlinuz - ядро Linux
- dev (для работы с девайсами, содержит узлы устройств. Список всех устройств), 
- etc (общесистемные настройки ОС и служб ОС, системные конфигурационный файлы, коллекция сценариев командной оболочки со системными службами),
    - /etc/crontab - файл, определяющий время запуска автоматизированных заданий,
    - /etc/fstab - таблица устройств хранения и точек монтирования
    - /etc/passwd - список учетных записей пользователей
- home (домашние директории пользователей, только в этих папках пользователи могут создавать и редактировать файлы), 
- lib (библиотеки для работы бинарных файлов, основными системными программами), 
- lost+found (содержит данные для частичного восстановления повреждений в файловой системе. Если с системой ничего не происходило, то он будет пустым. Каждай раздел или устройство отформатированные  ext3 имеют тут каталог),
- media (точки монтирования для съемных файловых систем), 
- mnt (временно монтируемые файлы, в старых системах вручную), 
- opt (дополнительное программное обеспечение, в основном коммерческое ПО), 
- proc (виртуальная файловая система, состояние ядра ОС в виде запущенных файлов, является каталогом процессов, параметров ядра и драйверов. Можно рассмотреть деятельность компьютера с точки зрения ядра ОС), 
- root (домашний каталог пользователя - администратора для восстановления системы), 
- run (о системе в момент загрузки, все процессы, которые сейчас запущены), 
- sbin (основные системные программы для администрирования и настройки системы, выполняют жизненно важные задачи, запускаются только суперпользователем), 
- srv (данные для сервисов, предоставляемых системой), 
- sys (информация об устройствах и драйверах операционной системы, некоторые свойства ядра), 
- tmp (временные файлы, в некоторых системах принудительно очищается при перезагрузке), 
- usr (вторичная иерархия для пользовательских файлов, для сохранения менее важных файлов, хранятся все программы и файлы поддержки. Содержит дополнительные каталоги bin, lib, sbin, share, share/doc), 
- var (изменяемые файлы, базы данных, буферные файлы, почта пользователя),
    - /var/log - файлы журналов с записями о действиях в системе. 

Директории в Linux
Все директории есть файлы, то есть являются просто потоком байтов, которые описывают поддиректории и файлы, которые в них содержатся. Каждый файл имеет путь, который начинается в корневом катологе root или /.
- Абсолютный путь - путь, который простраивается от корневого католога и может параллелен или удален от текущей директории. Начинается с /. Понятен в любом месте файловой системы. 
- Относительный путь - начинается с "." или с буквы и обращается только к директориям и файлам, находящимся в текущей директории. Может быть простроен только из текущей директории. 

Как устанавливается ПО в Linux - 3 варианта: 
- из исходных кодов, через компиляцию - возможность модифицировать ПО, установки без прав администратора в домашнюю директорию пользователя, при этом поиск зависимостей очень долгий, отсутствие контроля устанавливаемого ПО. При таком способе мы компилируем ПО в бинарные файлы, а бинарные файлы перепесывают соответствующие блоки в ядре ОС. 
- из пакетов, быстрая вещь, если все зависимости есть, то просто распаковка архива и перепись бинарного кода в нужных местах ОС. Пакет - готовый скомпилированый бинарный файл и список нужных зависимостей. Наличие контроля версий ПО. Есть пакетные менеджеры, которые распаковывают пакеты и контролируют версии. Пакетный менеджер хранит инфомрацию о версиях и списках установленных ПО. Нужны права администратора. Пакеты создаются под определенную версию, определенный дистрибутив Линукс. Пакетные менеджеры rpm для yum, dep для dppg.
- из репозитория. Наиболее приятный и распространенный способ - из репозитория. Место хранения файлов и библиотек, которое поддерживает потребность в зависимостях каждого ПО. Все зависимости в репозитории удовлетворены и сразу предлагает установить все нужное, спрашивает лишь занятие определенного места на компьютере. Репозиторий может быть Локальным или на сайтах - АппСторе, ПлейМаркет, Маркет.

# 4. Версии Linux.
Линукс - по сути только ядро ОС с возможностью как на конструкторе дособирать все нужные нам составляющие. Поэтому официальной версии Линукс не существует. Первую версию создал Линус Торвальдсон в 1991 году. Существует возможность через пользовательский интерфейс посикс обращаться к ядру из пространства пользователя. Линукс была доработана и обрела операционное окружение от GNU, важной частью которого был компилятор с языка С на язык машины. 
Официальное ядро - vanila kerner, которое можно получить на официальном сайте kerner.com. Распространяется на правах общественной лицензии, по которой каждый может получать и дорабатывать программное обеспечение, в том числе и ядро. ОС - ядро и набор программного обеспечения в структуре каталога, менеджер пакетов. Для изучения лучше брать ту ОС, на которую больше всего документации. 

Дистрибутивы - Варианты ядра и наполнения ОС: 
- Red Hat/CentOS/Fedora: Редхат подобоные системы: Red Hat - коммерческий продукт, свободная база, серверное направление, дополнения и обновления за деньги, есть поддержка за деньги, обновления не часты, основная забота - стабильность. CentOS - бесплатная версия для серверов, пакеты взаимозаменяемые, большое сообщество, но нет платной поддержки. Fedora - свободный полигон для испытания новых программ, меньший упор на стабильность и больший на новаторство, чаще подходят для персональных компьютеров.
- Debian/Ubuntu (как правило для ПК): Дебианподобные версии это Debian - расчитана на стабильность, пакеты свежее, чем в ред хат, но далеки от последих версий, для ПК. Ubuntu - максимально свежие и стабильные пакеты как правило для ПК. 
- Gentoo - только ручное управление, максимально гибкая.
- Slackware - не стоит никаких автоматизаций, только ручное управление. 

На 2024 самые популярные и удобные дистрибутивы - Fedora, Debian, менее известные, но уже сильные проекты LMDE, ARCH Linux, кроме того доступные обычным пользователям российские дистрибутивы - ALT Linux и Calculate Linux

Ubuntu и Fedora имеют возможность запускаться с Live CD, но данный способ работы дистрибутива медленнее, хоть и проще и не требует установки на диск. Кроме того настройка Linux на ноутбуке сложнее и имеет ряд ограничений. 

Сложности на пути изучения Linux:	
- непривычная структура файлов, 
- непривичное взаимодействие с программами, 
- длинные команды, 
- знание аттрибутов каждой команды, 
- огромные конфиги.

# 5.Базовые команды  Git
Все команды пишутся в следующем порядке: команда - ключи - аргументы (значения, названия). Разделителем всегда является пробел. Ключ начинается с "-" или "--" и указывает, как именно исполнить команду. 
Все есть файлы. Поэтому файлы можно группировать и разбирать по отдельным аттрибутам. 
Маска файла - определяет группу файлов, имеющих сходное строение названия. Например маска "(звездочка)2_o" удалит все файлы, которые оканчиваются на 2_o. а маска "file*" удалит все, которые начинаются на "file" Звездочка "*" заменяет любое число символов, а знак вопроса "?"  только один символ. При появлении знака Звездочки, командная оболочка подставляет в эту маску любые доступные ей значения. Знак "^" обозначает начало строки.
Также можно использовать следующие вариаенты переменных
[abcd] - любой перечень входящий в перечень
[!abcd] -  любой символ не входящий в перечень
[[:класс:]] Любой один символ, принадлежащий указанному классу
    [:alnum:] Любой алфавитно-цифровой символ
    [:alpha:] Любой алфавитный символ
    [:digit:] Любой цифровой символ
    [:lower:] Любая буква в нижнем регистре
    [:upper:] Любая буква в верхнем регистре
[![:класс:]] Любой один символ, принадлежащий указанному классу

При работе со множествами в выводе команд потребуется знание фигурных скобок {}. Установив их можно получить множесто, в том числе соединенное с другими множестами. Например:
1) {1..5} выведет цифры 1 2 3 4 5. 
2) {1..5}test выведет 1test 2test 3test 4test 5test. 
3) {1..3}test-{1..3} выведет 1test-1 1test-2 1test-3 2test-1 2test-2 2test-3 3test-1 3test-2 3test-3. 
4) {1,4,6} выведет 1 4 6. 
Пробел всегда прекращает работу с множеством. 
Указывая для команд мы можем указывать $(что-то), тогда команда отработает на том, что подразумевается под "что-то". 
Подстановка параметров, подстановка значений арифметических выражений и подстановка команд все еще выполняются в двойных кавычках. Без кавычек командная оболочка воспринимает все смены положения - пробелы, ввод, смена строки, табуляция, как разделитель слов, поэтому выводит результат в строку строго с одним пробелом между разделенными символами. 
Одиночные кавычки подавляют все правила командной оболочки, выводя маскимально то, что передано. Если нужно экранировать только один символ - перед этим символом ставится знак "\".

Кроме того есть Управляющие последовательности, приданные от прошлых программ: \a Звонок («предупреждение» — заставляет компьютер подать звуковой сигнал), \b Забой (backspace), \n Новая строка (в Unix-подобных , системах этот символ выполняет перевод строки), \r Возврат каретки, \t Табуляция. 

- Если в качестве ключа указать --help, то можно посмотреть справку по данной команде с описанием и всеми ключами, которые в ней есть

### Работа с терминалом:
- history - выводит историю всех команд, которые были сделаны. после команды написать цифру, выведет столько последних строк, сколько цифра.
    - Для применения полученной информации вы можете вводить ! и номер строки с нужной командой и это команда выполнится. Это особенно актуально, если команды длинные. 
- cal - выводит календарь текущего месяца
- echo - Выводит на экран указанное значение. В качестве аргумента можно ввести конкретное слово или фразу, тогда командная строка просто ее выведет. Также выводит переменные значения - текст, значение переменных, которые начинаются с $. Позволяет получить информацию о Переменных.
    - -e включает управляющие последовательности после обратного слеша
- echo $? - вывод кода возврата последней команды, выводит код возврата последней команды - если он равен 0, то команда выполнена корректно, если не 0 - команда выполнена с ошибкой, которую можно идентифицировать по выведенному числу.
    - в формате $(()) может выводить результат арифметических вычислений. кроме сложения, вычитания, умножения и деления умеет "%" Деление по модулю или остаток от деления, "**" Возведение в степень
- man - полная подробная инструкция, как пользоваться той или иной командой. Пишется man и далее название команды. Часто ман равно хелп, но иногда ман более подробна и объемна. Поставив цифру перед искомой командой можете посмотреть конкретный раздел мануала: 1 Пользовательские команды, 2 Программные интерфейсы системных вызовов в ядре, 3 Программные интерфейсы в библиотеке C, 4 Специальные файлы, такие как узлы устройств и драйверы, 5 Форматы файлов, 6 Игры и развлечения, такие как хранители экрана, 7 Прочее, 8 Команды системного администрирования.
    - -k покажет глобальный поиск по мануалам с искомым значением. 
- vi - вывод текстового редактора. vi &&& вывод текстового редактора для файла с именем &&&	текстовый редактор, встроенный в баш. вызов. открытие. ":" в текстовом редакторе для вызова панели управления. ":q" - выход из тектового редактора. ":q!" - принудительный выход из тектового редактора. ":w" - записать изменения.
- less - режим просмотра в терминале.Управление - стрелки, Пейдж ап и даун. Q - выход. Через / поиск по документу. прочитывает нужный файл, управление гораздо проще - мможно стрелочками вверх и вниз по строкам, а также PageUp и PageDown по страницам. G - возврат к концу документа, g - возврат к началу документа. через "/" можно искать ближайший такой набор символов, а следующие вниз искать через "n". Можно организовать поиск по документу, для этого нажимаем "/" и вводим нужное слово. Слова в тексте выделяются. H - вывод справки. 
- more - постраничный вывод файла или результата процесса в терминале. Вниз листать можно, вверх - нет. Прочитывает нужный файл, можно просматривать постранично через пробел, или построчной через ентер. чтобы выйти - нажимаем Q.
- clear - очистка экрана терминала
- cd - переход в нужную директорию. Если ввести ее без аргументов, то всегда попадаешь из любого места в домашнюю директорию пользователя, который установлен, как администратор. Если выбрать аргумент в виде любой директории. как вышестоящей. так и параллельной, то текущей рабочей директорией станет она. 
- type - интерпретирует тип команды, является ли она исполняемым файлом (hashed + путь к файлу), алиасом нескольких команд (aliased) или команды с ключами, или внутренней функцией командной строки (shell builtin), например Баш. 
- which - выводит на экран интерпретированный тип команды и расположение его исполняемого файла. Баш ищет значение команды сначала в своей библиотеке, потом в алиасах, потом в строгом соответствии с расположением в PATH в директориях, чем раньше в директориях найдет - на том и остановится. 
- whereis - выводит расположение исполняемого файла команды и файлы документации и конфигурации.
- alias - объединение в алиас. Команда без аргументов выведет список текущих псевдонимов в командной оболочке.
    - alias.&&& '!???;???'	объединение в алиас, где &&& - название алиаса, а после него идет описание команды в ' ' и помечено ???, и таких команд две, через точку с запятой, перед первым стоит ! восклицательный знак
    - alias.&&& '???' - , где &&& - название алиаса, а после него идет описание команды в ' ' и помечено ???
- apropos выводит список подходящих услуг не всегда точная, делает тоже, что и man -k
- info выводит информацию из справочника INFO, который содержит древовидную структуру с гиперссылками на другие статьи
- whatis выводит в одну строку описание команды
- help получение справки о команде, встроенной в систему может быть введен после команды с "--" перед собой, в этом случае выведет синтаксис, а может стоять как команда, тогда будет только описание
- zless чтение файлов формата gz Включает в себя расширение, способное читать запакованные текстовые файлы gzip.
- unalias снимает алиас с определенного набора команд
- sort сортирует строки текста сортировка происходит по базовому принципу - алфавит, можно настроить
- uniq сообщает о повторяющихся строках или удаляет их -d с этим ключом показывает дублирующиеся строки убирает из вывода только уникальные строки без дублей
- printenv выводит список доступных в системе переменных
- script запись в файл целых сеансов работы с командной строкой  
- find 	поиск по системе	-user &&& - поиск файлов, чьим владельцем является &&&. 
- shutdown 	останавливает или перезагружает систему
- printenv	выводит часть или все окружение, чтобы оценить количество переменных и их значения		можно отсортировать нужные переменные или вывести значение конкретной переменной
- set	выводит переменные и окружения, и командной оболочки		установка параметров командной оболочки
- export	экспорт окружения для отложенных программ		
- nano	вызов текстового редактора		
- exit - выход из консоли

### Поиск информации:
- date - текущие дата и время.
- uname - выводит информацию о версии ядра ОС 
- ls - вывод списка файлов в указанной директории. 
Имеет ключи:
    - -l - с описанием файлов. если в начале будет "-", то это файл, если в начале будет "d", то это директория, "l", то это link - ссылки. После этого обозначения идут 9 символов с отражением прав на файл. Число хард линк, имя пользователя, имя группы, размер, дата изменения, имя файла.
    - -la - вывод списка со скрытыми файлами, в формате с подробным описанием. если в начале будет "-", то это файл, если в начале будет "d", то это директория, "l", то это link - ссылки, если начинается с ".", то это скрытый файл.
    - -li - вывод списка с инфомрацией об inode файла. 
    - В качестве аргумента можно указывать любую директорию, тогда покажется состав именно этого каталога.
    - В качестве аргумента можно указать "..", тогда покажется содержимое вышестоящей директории. 
- lsblk - выдает информацию о блочных устройствах в системе, показывает, отображает, выводит блочные устройства в системе
    - -o UUID покажет ЮИДы дисков без привязки к конкретному. 	
- pwd - выводит информацию о текущей директории. Важная информация для понимания текщего состояния. 
- stat - вывод информации о файле, выводит информацию из айноды файла, показывая номер айноды, тип, размер, число блоков, доступы, юид, гид, даты действий с файлом, его права.
- df - показывает свободное пространство файловых систем/ диск фри, свободное место на диске, сколько места на диске, какое свободное место есть на диске. 
    - df -i - показывает свободное пространство в айнодах. 
- wc - подсчет слов. Выводит число символов перевода строки, слов и байтов в каждом указанном файле
    - wc -l - подсчет строк	
- grep - global regular expression print. утилита для поиска информации по конкретным ключам в конкретном файле. grep, далее в кавычках текст поиска, с учетом регистра, в конце файл, в котором нужно смотреть. -i убирает зависимость от регистра. 
- head - выводит только верх файла, то есть первые строки. по умолчанию 10 строк, но с ключом -"число строк" можно вывести нужное число строк. Чтобы данная утилита с ключом числа строк работала всегда рекомендуется использовать в формате -n 3, где 3 число строк. 
- tail - выводит последние строки файла. Те же самые ключи, что у head. Но есть еще ключ 
    - -f, который выводит нужное число последних строк и дальше следит за файлом, выдавая информацию о новых строках. Полезна для дебага или траблшутинга на нашем сервере. Выдает строчки с причинами ошибок и прочими данными. Выход из режима отслеживания черех CTRL+С.

### Работа с файлами:
- file - показывает тип файла
- touch - создание файла или обновление до текущего времени. Создает в текущей директории файл с названием после данной команды. Либо, если такой файл уже есть - то обновляет его время создание на сейчас. Можно указать через пробел несколько файлов, тем самым проработав с несколькими файлами.
- fallocate - создает файлы определенного размера	fallocate -l 10MB file1 создаст файл file1 размером 10 мб
- mkdir - создание директорий. Имеет возможности как создания одной директории, так и целой ветки директорий. 
    - Если после команды написать название директории, то произойдет создание новой директории с таким названием в текущей директории. Если через пробел указать несколько имен, то можно создать несколько директорий в текущей директории.
    - -p - данный ключ позволяет создавать несколько последовательных директорий. Если в аргументе через "/" указать несколько новых названий, то в текущей директории создастся директории, в ней еще одна и так далее, в зависимости, как глубоко вы прописали путь через "/". Вариант написания 'mkdir -p &&&/???/**' - создание ветки несуществующих директорий &&&, начиная с текущей директории. Следующие директории ??? и **. 
- mv - переносит файл или директорию из одного места в другое. При этом в исходном месте переносимый файл или директория удаляются. Аргументы - что и куда. Если данная команда используется на файл или директорию, то при введении нового имени файла в аргумент куда, то файл или директория просто переименуется. Если команда используется на директорию, которой не существует - директория создается. При перемещении в директорию можно указывать несколько файлов.
    - -u - копирует только те файлы, которые имеют более свежую дату или отсутствуют в новом каталоге. 
    - -i - спросить, если потребуется перезаписать старый файл.
- cat - выводит на экран содержимое файла, который записан в ее аргументе. 
    - cat  .git/logs/** - показывает наполнение файла с логами ссылок - действий по изменению, удалению по конкретной ветке **
    - cat> файл (даже новый) и далее можно записать все, что нужно в терминале. Ctrl+d. Вход из режима записи. 
    - cat file1>file2. Перезапишет файл 2 данными из файл 1. 
    - cat file1>>file2. Дополниn файл 2 данными из файла 1.
- cp - копирует файл или директорию из одного места в другое. копирует со всеми аттрубутами, вплоть до времени создания. Аргументы - что и куда. Если папки, куда копировать не существует, то она создается. Можно копировать несколько файлов, в качестве места можно указать файл, тогда он заменится, можно указать директорию, тогда в ней создадутся или заменятся файлы.
    - -r - копирует рекурсивно директорию, то есть все, что в ней есть и ее саму в нужное место. Аргументы те же самые. Что и куда. Если папки, куда копировать не существует, то она создается. 
    - -u - копирует только те файлы, которые имеют более свежую дату или отсутствуют в новом каталоге.
    - -a - копирует со всеми идентификаторами и правами, иначе будет ставиться по умолчанию. 
    - -i - спросить, если потребуется перезаписать старый файл.
- rm - удаление конкретного файла, который не является директорией. удаляет файлы, но не директории. можно выбрать как конкретный файл с именем, так и группы файлов, которые попадают под маски. Можно просто указать перечень файлов для удаления. Система не позволяет отменить удаление, поэтому внимательно проверяйте, лучше через команду ls список файлов, которые будут удалена, и только после этого заменяйте ls на rm.
    - -i - запрашивать разрешение на удаление файла.
    - -r - удаление директории как файла, включая все его содержимое - поддиректории и файлы
    - -fr - удаление принудительное директорий, включая скрытые файлы и директории. в том числе и их поддиректории и файлы в них. 
- rmdir - удаление пустых директорий и только пустых директорий. если в директории есть скрытые файлы, то директория удалена не будет. 
- chmod - изменение прав на файл или директорию. для владельца, группы владельца и всех остальных. Может быть как в буквеннов формате, так и цифрами. смена прав, установка прав на чтение, исполнение, запись.
    - chmod -x &&& - редактирование прав на файл, на невозможность исполнения. где &&& - имя файла. 
    - chmod +x &&& - редактирование прав на файл, на возможность исполнения. где &&& - имя файла. 

### Пользователи:
- who - кто сейчас работает на сервере - показывает имя пользователя, с какого терминала, когда и с какого адреса подключился. Для того, чтобы понять, одни ли работаете на сервере. К какому терминалу подключен.
- whoami. показывает текущего активного пользователя.
- id - команда. которая выводит информацию о пользователе, чье имя указано в аргументе этой команды. Покажет UID, GID, группы. в которые входит.
- sudo - позволяет выполнять команды от имени пользователей, в том числе от имени пользователя root.  
    - sudo -i / sudo su / sudo su $ИМЯ_ПОЛЬЗОВАТЕЛЯ - любая из команд переключит нас на пользователя root.
    - -l - позволяет посмотреть все разрешения на действия от имени суперпользователя для текущего пользователя. 
- usermod - команда, позволяющая осуществлять действия с настройками пользователей. имеет множество ключей для передачи и сокращения числа прав каждого из пользователей. 
- umask определяет разрешение файлов по умолчанию при их создании
- su запуск командной оболочки от другого пользователя -с - запуск конкретной одной команды от имени суперпользователя чаще всего от суперпользователя, для начала - требуется ввести пароль того пользователя, под кем хотите войти. Запускает новую командную оболочку
- chown изменение владельца файла только от имени суперпользователя. Синтаксис - присвоить права владельца: 
1) просто имя = пользователю, 
2) имя:группа = пользователю и группе, 
3) имя: = пользователю и его группе. 
4) :группа = группе
- chgrp изменение группы файла только от имени суперпользователя, только группу меняет владельца. устарела.
- passwd изменение пароля пользователя изменяет пароль указанного пользователя

### Работа с каталогами:
- ln - создание Линка - еще одной записи в каталоге, еще одного имени файла, которая будет иметь ту же айноду и те же права, что и основной файл. Все хардлинки между собой равны и являются главными. При изменении прав или наполнения любого из хардлинков - меняются и все остальные. 
    - ln -s - создание мягкого линка - ярлыка файла. Права полные у всех. Перед началом файла, на который будет ссылка обязательно стаьте путь, можно "../"
- df -h - показывает подмонтированные диски с каталогами. Но не показывает каталоги связанные с другими каталогами, подмонтированные с функцией байнд.
- mount 	вывод каталогов в том числе в оперативной памяти, до катологов подмонтированных дисковых устройств. берет из католога /etc/mtab, который является симлинком на /proc/self/mounts, этот файл содержит точки монтирования.
    - sudo mount /dev/sda /mnt/ - подмонтирует sda из каталога dev в mnt, где хранятся временные блоки для работы с устройствами. Подмонтирование диска к определенной папке даст возможность работать с его данными через драйвера, не делая этого вручную.
    - --bind можно монтировать одну папку к другой.
- umount - чтобы отмонтировать диск от определенной папки.
- mkfs - определяет файловую систему раздела диска	
    - Например mkfs.ext4 и путь до файла логического диска (/dev/что-то)
- cfdisk - утилита для просмотра и создания логических дисков

### Пакеты и установка:
- ssh-keygen - генерация ключа для работы над репозиторием .pub - публичный .rsa - внутренний и личный
- yum - предоставление данных из системы пакетному менеджеру. установка, поиск программ программного обеспечения
    - -search поиск всех пакетов конкретной программы. 
    - -install под sudo установка нужного программного обеспечения, в конце названия программы ставим "d".
    - -provides находит все пакеты, относящиеся к даннму файлу. 
    - -remove удаление пакета, но не его зависимостей только под судо.
- rpm - работа с файлами в пакетах на диске, пакетный менеджер, поиск, удаление пакетов, сбор информации по файлам в пакете.
    - -ql поиск всех файлов в пакете. 
    - -qa вывод всех пакетов для поиска по ним. 
    - -e удаление пакета файлов.
- free - показывает свободное пространство в памяти в системе.
- du - сбор информации о размере занятой памяти.
    - du -sh показывает только размер всей памяти занятой. 
    - du -sh ??? - покажет размер конкретной директории или файла ???
- apt autoremove - удаляет программы, которые были установлены как зависимости, но изначальные программы уже удалены.
- apt dist-upgrade - обновление пакетов с зависимостями.
- apt install - установка конкретных файлов из пакетов.
- apt purge - удаляет из системы программу и ее конфигурационный файлы.
- apt remove - удаляет только саму программу из системы.
- apt update - обновление системы.
- apt upgrade - обновление существующих в системе пакетов.

### Работа с проектами:
- tree - вывод дерева проекта
    - -a выводит все директории с поддиректориями

### Процессы и управление
- top - показывает загрузку системы. В первой строчке показвается время сервера, сколько времени сервер без перезагрузки, сколько пользователей на нем. Load average - за минуту, за 5 минут, за 15 минут. Количество процессов в очереди на ожидание пользование ресурсами. Чем больше - тем более нагружена система.
- ps - показать список процессов. 
    - -e вывести все процессы в системе, 
    - -f показать полностью информацию, 
    - -l в длинном виде.
    - ps х - выводит процессы, независимо от терминалов, которые ими управляют
    - ps aux - выводит более подробную информацию о процессах. 
- pstree - показать дерево процессов в системе	
- vmstat - собирает статистику использования виртуальной памяти
- kill - посылание сигналов процессу. имеет формат -<signal> <PID>, где определяется какой сигнал какому процессу посылается. Чаще всего служит просто для закрытия процессов.
- jobs выводит список активных заданий
- bg переводит задание в фоновый режим работы либо можно сразу запускать программу в фоновом режиме, введя после нее знак &. После перевода или запуска фоном программа будет отражаться в списке работающих, будет иметь номер.
- fg переводит задание в режим работы на переднем плане возвращает указанную программу в активную оболочку. Имеет синтаксис fg %1, где 1 - номер процесса. "%1" Называется Спецификатором процесса.
- killall останавливает процессы по именам позволяет остановить сразу несколько процессов, например одного пользователя, или с одинаковым названием. 
- xload показывает изменения нагрузки на систему с течением времени
- tload показывает изменения нагрузки на систему с течением времени на графике

### Работа с потоками:
- tee - направление потока в файл и на экран, одновременное направление потока на экран и в файл с перезаписью файла
    - tee -a - одновременное направление потока вывода на экран и в файл без перезаписи	

### Сети
- ss - какие порты доступны на нашем сервере	
    - -t - соответствуют TCP/IP. 
    - -u - соответствует UDP. 
    - -n - показывает номера портов, а не их имена. 
    - -l - слушающие. 
    - -p - понять программу, слушающую порт, только от судо.
- netstat - сбор информации о сетевых соедиенениях	
    - netstat - tulpn информация про сервисы через интернет
- ip a - вывод информации об айпи серверах.	
    - ip addr show аналог команды.
- ip r - вывод информации о шлюзе.

# 6. Работа с bash. Позволяет быстрее и точнее работать с оболочкой. 
- TAB - клавиша позволяет либо дополнять написанную команду или аргумент однозначным завершением. Либо при двойном нажатии вывести на экран список всех завершений. 
- ВВЕРХ - поиск предыдущих команд и автоматическое и занесение в текущую команду. Если в строку подставить !!, то она возмет полностью предыдущую команду. Хранит до 500 команд, что очень удобно, если нужно быстро набрать ранее использованную команду, либо немного ее изменить. 
- Переменные окружения, которые содержат информацию о конфигурациях и настройках, влияющих на работу Линукс. 
- $HISTSIZE	переменная размера истории команд баш, по умолчанию 1000
- $PATH	показывает пути для поиска командной оболочкой исполняемых файлов. 
- $? выводит код возврата последней команды - если он равен 0, то команда выполнена корректно, если не 0 - команда выполнена с ошибкой, которую можно идентифицировать по выведенному числу.

Чтобы дополнить переменную из командной оболочки необходимо прописать "название_переменной=$название_переменной&&&", где &&& заменяются на нужный текст, который необходимо придать переменной. Например Foo=$Foo1. В конце переменной Foo добавится "1". 

Связки команд
- Через логическое "и", где две и более команд будут выполнены вместе, но только если все они могут быть выполнены. Команды связываются значком "&&". 
- Через логическое "или", где две и более команд сравниваются, пока хотя бы одна из них не выполняется - выполняются слева направо. Команды связываются значком "||".
- Через логическое "не имеет значения", где любые команды будут исполнены независимо от исполнения предыдущих. Команды связываются значком ";".
- Через значок "|" связывается последовательность команд от первой до последней. Создание последовательности направления потока, направление нескольких потоков подряд из одной команды в другую, вывода второй на ввод в третью и так далее.
- ">" направление потока в файл	
- "<" обратное направление потока или принимает данные из вывода другой программы или файла. направления потока в конкретный файл, перезапись в нем всех предыдущих данных. перенаправление, запись. Обязательно указывать номер потока, так как по умолчанию это только 1 - вывод.
- ">>" направление потока в файл. направления потока в конкретный файл, дополнение в нем всех предыдущих данных. перенаправление, запись. Обязательно указывать номер потока, так как по умолчанию это только 1 - вывод.

Команды работают через командную строку, а вернее через командную оболочку - программу, которая компилирует понятный человеку текст в понятные машине запросы. 
Bash - базовая командная оболочка от GNU, которая стала доработанной версией shell из системы Unix. 
При работе с графическим эмулятором командная строка работает через эмулятор Терминала, который иногда для простоты называется Терминалом. 
Для ввода команд последняя строка должна содержать призыв к вводу, для этого в конце строки стоит знак $ для обычного пользователя и # для суперпользователя. 
При работе в командной строке можно ользоваться мышью выставляя курсор, зажатием левой кнопкой выделяется текст, а также двойным нажатием левой кнопкой выделенный текст копируется, а средней кнопкой вставляется. 

Для управления внутри терминала кроме команд есть наборы сочетаний клавиш, которые позволяют выполнять различные действия. Графическая оболочка иногда может перехватывать некоторые сочетания клавиш, но в чистом терминале они работают. 
- CTRL+A Перемещает курсор в начало строки. 
- CTRL+E Перемещает курсор в конец строки
- CTRL+F Перемещает курсор на один символ вперед; действует так же, как клавиша со стрелкой вправо
- CTRL+B Перемещает курсор на один символ назад; действует так же, как клавиша со стрелкой влево
- ALT+F Перемещает курсор на одно слово вперед
- ALT+B Перемещает курсор на одно слово назад
- CTRL+L Очищает экран и устанавливает курсор в левый верхний угол. То же самое делает команда clear

Все эти команды находятся в библиотеке Readline. Там же находятся операции вырезания и вставки: 
- CTRL+D Удаляет символ в позиции курсора. 
- CTRL+T Меняет местами два символа — в позиции курсора и предшествующий ему/
- ALT+T Меняет местами два слова — в позиции курсора и предшествующий ему
- ALT+L Переводит в нижний регистр символы, начиная с символа в позиции курсора и до конца слова
- ALT+U Переводит в верхний регистр символы, начиная с символа в позиции курсораи до конца слова
- CTRL+K Удаляет символы от позиции курсора до конца строки
- CTRL+U Удаляет символы от позиции курсора до начала строки
- ALT+D Удаляет символы от позиции курсора до конца текущего слова
- ALT+BACKSPACE Удаляет символы от позиции курсора до начала текущего слова. Если курсор находится в начале слова, удаляется предшествующее слово
- CTRL+Y Извлекает текст из кольцевого буфера удалений и вставляет его в позицию курсора

- ALT+? Выводит список возможных дополнений. В большинстве систем аналогичный эффект можно получить, нажав клавишу TAB второй раз, что намного проще
- ALT+* Вставит все возможные дополнения. Это пригодится в том случае, если требуется использовать больше одного возможного варианта дополнения

Кроме поиска истории команд и работы с ними через команды можно использовать сочетания клавиш:
CTRL+R - поиск по истории команд,
CTRL+J - копирование найденной информации.
CTRL+P Переход к предыдущей записи в истории. Действует так же, как клавиша со стрелкой вверх. 
CTRL+N Переход к следующей записи в истории. Действует так же, как клавиша со стрелкой вниз. 
ALT+< Переход в начало (к первой записи) списка истории.
ALT+> Переход в конец (к последней записи) списка истории.
CTRL+R Инкрементальный поиск в обратном порядке. Поиск выполняется поступательно, от текущей записи вверх по списку истории.
ALT+P Поиск в обратном порядке, не инкрементальный. При использовании этого вида поиска введите искомую строку и нажмите ENTER, и только после этого будет выполнен фактический поиск. 
ALT+N Поиск в прямом порядке, не поступательный.
CTRL+O Выполнить текущую команду в списке истории и перейти к следующей. Эту комбинацию удобно использовать, если требуется повторно выполнить последовательность команд из списка истории.

Командная оболочка хранит данные в переменных командной оболочки, которые инициированы ей самой, и переменных окружения, которые принадлежат всем остальным. Кроме того существуют данные в Псевдонимах и Функциях командной оболочки. Когда мы входим в систему, запускается программа bash и читает содержимое серии конфигурационных сценариев, называемых файлами запуска (startup files), где определяется окружение по умолчанию, общее для всех пользователей. Затем она читает дополнительные файлы запуска в вашем домашнем каталоге, где определяется личное окружение. В Командной оболочке входа bash читает /etc/profile и файл личного профиля пользователя. После процессы этой командной оболочки наследует Простая командная оболочка, которая уже читает /etc/bash.bashrc и личный пользовательский файл запуска ~/.bashrc. 

При работе с конфигурационными файлами нужно использовать текстовые редакторы, которых очень много, самые популярные: kedit, kwrite, nano, vi, vim, kate, gedit, emacs. Обязательно при редактировании конфигурационных файлов создавайте копии, которые обычно создают с пометками .bak, .sav, .old, .orig. Оболочка читает данные конфигурационного файла .bashrc только при запуске, а соответственно при изменениях нужно перезапустить программную оболочку. Изменения эти могут быть - новые псевдонимы, изменения значений переменных. Обязательно пишите комментарии, которые начинаются с # в начале строчки. А также убирайте не нужные строчки, выставляя перед ними #. Удаляйте в крайнем случае. 

# 7. Пользователи в операционной системе Linux.
Имя пользователя - не длинее 32 символов, не может содержать : и новой строки. Это строка. Это псевдоним, который нужен для удобства пользователя. 
Для системы важен другой способ идентификации пользователя - UID  - Это числовое поле, которое может принимать числовое значение от 0 до 2 в 32 степени минус 1. Идентификация пользователя и его прав. Только по UID. 
Имена пользователя могут быть одинаковыми, но разные UID. Из-за этого система может ограничивать права доступа к ресурсам. 

В Линукс два вида пользователей: root, у которого UID=0. И все остальные, у которых UID больше 0.
Пользователь  root не имеет никаких ограничений, кроме технических. Единственный админский доступ, к которому не применяется никаких ограничений. Может менять, добавлять и удалять какие угодно файлы. 
Все остальные пользователи для удобства разделены на служебные и обычные, но для системы этого разделения нет. 

Для служебных выделяются специальные UID, под которыми они работают. Служебные относятся к программам, которые работают без взаимодействия с пользователями. Эти программы - Демоны - программы, которые запускаются системой, работают в фоне, не взаимодействуют с пользователем. Программа, ожидающая в фоновом режиме какого-то события и реагирующая на него. 
Все программы должны быть запущены от какого-то пользователя, если это будет пользователь root, то программа получит доступ ко всей системе, что небезопасно. 
Обычные полльзователи - люди, имеют домашние директории, ограничения по правам доступа. 

При попытке доступа в систему пользователь проходит сначала аутентификацию - сравнение логина и пароля с хранящимися в системе. А после авторизацию - на наличие прав доступа к программе или серверу. 

Файлы для хранения инфомрации о пользователях:
-  /etc/passwd - Содержит список пользователей с полями - имя, ИКС, UID пользователя, GID - идентификатор группы юзера, комментарий, домашний каталог пользователя, командная оболочка. Отражает также права, которые есть у пользователя. 
- /etc/group - Содержит список всех групп, к которым отнесены пользователи данной системы. Формат отображения - имя, ИКС, GID - идентификатор группы, участники группы. Вносить изменения в права пользователей можно только от имени администратора. При помощи команды usermod.
- /etc/shadow - Хранит в себе ХЭШ - результат hash-функции, которая не имеет обратного преобразования. По сути - документ со всеми паролями, которые хранит система. Может быть открыта только под администратором. Хранение паролей не осуществляется, только преобразованный в хэш пароль. Поэтому восстановить пароль нельзя, можно только сбросить.  

У пользователей есть разные права по отношению к разным файлам. Типы прав:
- чтение - (r)
- запись - (w)
- исполнение - (x)

Также права разделяются по отношению к владельцу файла: Сам пользователь, его группа пользователей, все остальные. 

Таким образом описание каждого файла при выводе полного отображения через list состоит из 9 символов, часть которых могут быть заменены "-", если данного права у данных пользователей нет. 

- rw-rw-rw- - все пользователи могут читать и изменять файл
-  rwx------ - только у владельца права на файл, остальные даже читать не могут.
-  rwxr--r-- - у владельца право на чтение, запись и исполнение, у остальных только чтение

Чтобы устанавливать данные права существует команда chmod, в аргументы которой можно писать через запятую все права, которые нужно добавить или убрать к конкретному файлу либо к директории (тогда после имени директории нужно поставить "/"). 

При изменении прав на директорию, права на ее содержание не изменяются. Но, если добавить ключ -R, то изменятся права на саму директорию и ее содержимое, в том числе в поддиректориях. Если у директории не будет прав на "r", то нельзя будет просмотреть список ее содержимого, но можно смотреть конкретные файлы в ней и работать. Если у директории не будет прав на "x", то нельзя открывать директорию и видеть информацию о ее содержимом кроме имен файлов. 

- чтобы поменять права владельца пишите u
- чтобы поменять права группы владельца - пишите g
- чтобы поменять права всех остальных - пишите o
- чтобы сразу поменять права для всех пользователей - пишите a

А дальше все, какие права нужно поменять "-" или "+" убрать или добавить. И какие именно права "r", "w", "x". 

Права можно поменять проставив в качестве аргумента для команды chmod числовое обозначение тех или иных прав

1. только исполнение 
2. только запись
3. только исполнение и запись
4. только чтение
5. только чтение и исполнение
6. только чтение и запись
7. все права

# 8 Файловая система

Для того, чтобы создать файл в системе необходимо выполнить 3 действия
- определить блок в 4кб в памяти диска - на файловой системе ext
- запретить иные операц с этим местом - хранится в inode - index node. 
- дать этому блоку название

Файл - именновая область на диске, который занимает один или несколько блоков. Каждый блок это 4 килобайта или 4096 байт. Любые файлы в пределах этого значения будут занимать один блок.

stat - выводит информацию из айноды файла, показывая номер айноды, тип, размер, число блоков, доступы, юид, гид, даты действий с файлом, его права. Файловые системы ext. 

В файле inode хранится вся инфомрация о файлах, в том числе права доступа. Можно посмотреть информацию о файле при помощи команды stat, в качестве аргумента - имя файла. Выведет всю информацию об этом файле. 

Число Айнодов ограничено, при необходимости их можно расширить, но самих по себе их определенное число. Также, для увеличения Айнодов нужно пересоздать файловую систему, что влечет потерю всех данных. При других файловых системах возможно динамическое выделенеие Айнодов. Например XFS. 

Чтобы увидеть свободное файловое пространство можно воспользоваться утилитой df - которая покажет информациюж о свободном месте. с ключом -i покажет свободные inod.

Имя файла хранится в каталоге, в котором показывается соответствие имени inod файла, а значит и его местоположение.  Директория и является таким каталогом, поэтому при запрете чтения директории мы не можем видеть названия файлов, которые в ней находятся. 

Соответственно, при удалении файла происходит удаление его имени из каталога и его inod освобождается, но не его данных, а также место он будет все еще занимать в файловой системе. Можно вручную просмотреть данные нужные нам на диске, но восстановить их как файл - невозможно. Потому что inod, в которой указаны ее местоположение и прочие аттрибуты уже свободна. Но данные можно восстановить вручную. 

Файл существует до тех пор, пока существует хоть один хардлинк на него. Хардлинк - это запись, которая ссылается на этот файл. 
При использовании команды ls показывается число ссылок на файл. А это - прежде всего записи в различных каталогах и в нижестоящих и вышестоящих директориях. Хардлинки нельзя создавать на каталоги, хардлинки актуальны только в пределах одной файловой системы. Хардлинки не занимают блоков. Софтлинки - занимают место, так как являются новыми файлами, ссылающимися на другие файлы. Софтлинки очень часто используются в линукс. 

В каталоге dev располагается перечень блочных устройств, которые являются файлами, аналогичными дискам. Если название диска представляет собой только буквы, то это физический диск. Если в нем присутствуют цифры - то это логический диск, выделенный на физическом диске.  Virtual File System позволяет работать с физическими дисками через единую систему, не смотря на различия в файловых системах дисков. VFS дает единообразный доступ к файловым системам любых клиентских приложений. Интерфес между ядром ОС и файловой системой конкретного диска. Чтобы обращаться к конкретным дискам не нужны специальные запросы, только драйверы переводчики с VFS на язык диска. 

Монтировние - связка файла дискового устройства с каталогом, чтобы внутри линукс можно было с ним работать по привычным принципам дисков. монтирование - связка операционной системы и файловой системы диска. иерархическая система, которая должна быть смонтирована при первом запуске Линукс. для запуска линукс нужно монтирование. ядро монтирует в корневую и хранится в файле /etc/fstab, куда, в какой системе смонтировано, с каким ЮИД и сколько штук. именно диск vda1 монтируется в операционную систему для связи с ядром. 

Команда df -h показывает подмонтированные диски с каталогами. Но не показывает каталоги связанные с другими каталогами, подмонтированные с функцией bind. 
Команда mount выведет вывод каталогов в том числе в оперативной памяти, до катологов подмонтированных дисковых устройств. берет из католога /etc/mtab, который является симлинком на /proc/self/mounts, этот файл содержит точки монтирования. proc является каталогом процессов, параметров ядра и драйверов. 
- mount - в вариации "sudo mount /dev/sda /mnt/" подмонтирует sda из каталога dev в mnt, где хранятся временные блоки для работы с устройствами. Только от лица администратора это возможно, поэтому sudo. 

Подмонтирование диска к определенной папке даст возможность работать с его данными через драйвера, не делая этого вручную. umount - чтобы отмонтировать диск от определенной папки. с ключом  --bind можно монтировать одну папку к другой Можно монтировать и образы через  sudo mount ~/file.iso /mnt.

Установка программного обеспечения:
Пакетный менеджер для Линукс Цинтос - rpm (рпм): отвечает за локальную установку, строит базу данных о пакетах и обновлениях,  а yum (юм) - надстройка для рпм для работы с репозиториями и предоставляет данные пакетному менеджеру. 
Для поиска конкретных программ (например нужен http сервер, который называется apache) используем ключ search, при таком поиске покажутся все пакеты, относящиеся к такому серверу. 
Команда wc -l показывает число строк. Лучше всего отсортировать при помощи grep. 
Чтобы установаить программу используем yum, только с ключом install. Эту команду можно использовать только под root. Чтобы установить - в конце названия программы пишем "d" - demon. 
rpm с ключом -ql запускает список всех файлов в пакете. Бинарный файл в папке бин или сбин - скорее всего запускает программу, к нему можно посмотреть ман для изучения вариантов. А также conf для изучения конфигурации, по которой он запускается. 

Поиск пакета по файлу - нужно при сообщении системы о нехватке какого-либо файла, чтобы можно было найти, в каком пакете этот файл находится. используем команду yum с ключом provides. находит все каталоги и файлы. Если нужна исполняемая команда, то ищем каталог bin, и можно при помощи греп искать. Можно найти каталог и файл, а по ним посмотреть, какой пакет соответствует этому файлу. 
найти пакет и его состав через рпм. rpm с ключом -qa запускает список всех пакетов в системе. их можно посчитать через wc. 
Для удаления используем yum remove и привилегии судо. Удаляется только пакет, но не его зависимости. А также rpm -e, который удалит пакет. 

Дополнительные типы файлов
с -  Специальный файл символьного устройства. Файлы этого типа соответствуют устройствам, таким как терминал или модем, которые обрабатывают данные как потоки байтов
b - Специальный файл блочного устройства. Файлы этого типа соответствуют устройствам, таким как привод жесткого диска или CD-ROM, которые обрабатывают данные блоками

Работа с текстовыми файлами и их редактирование:

Самый распространенный текстовый редактор под Linux - vi, он входит в стандарт Posix, очень легковесный и доступен всегда. Был первым, кто заменил строчные текстовые редакторы, экранный. Имеет улучшенный вариант в виде vim, который подразумевается под командой vi в современных Linux системах. 

Команды внутри vi: :q - выход, :q! - принудительный выход. Если заблудились - нажмите два раза Esc. Vi - режимный редактор, поэтому сначала вы находитесь в режиме команд, что значит, что ввести текст можно только после перехода в режим вставки при помощи кнопки I (i). Esc - позволит выйти из режима редактирования. :w - сохранение изменений. 

VIM имеет два режима - совместимый с vi и полный. Для перехода в полный режим откройте его командой vim, или пропишите echo "set nocp" >> ~/.vimrc. Если vim вовсе отсутствует, то подгрузите его sudo apt-get install vim. 

Курсор перемещается стрелками, мышью, или кнопками HJKL. Кроме того много операторов перемещения курсора, из которых интересны SHIFT+G (G) - К последней строке в файле, число-SHIFT+G - К строке с указанным номером (например, команда 1G выполнит переход к первой строке в файле), 0 (ноль) - В начало текущей строки. 

Если вы не редактируете существующий файл, но создаете новый, то при записи через w просто вставьте путь и название файла и он создастся. Также редактирование можно начинать с команд o или a. В командном режиме нажмите U, чтобы отменить предыдущее изменение. vi отменяет только самую последнюю операцию. vim отменяет множество операций. В командном режиме удалять символы можно командой x, а целые строки командой dd. Вообще команда d имеет множество дополнений для удаления по разным признакам, например dG удалит все до последней строки. Но на самом деле d - вырезает текст, который можно позже вставить командой p. Просто копировать тест можно командой y. Команда y имеет такие же признаки, как и команда d. Команда J позволяет объединять строки. 

Команда f ищет следующий указанный символ в строке и переходит к нему, через ; можно продолжать поиск символа в данной строке. Команда / делает тоже, но во всем файле, только дальнейший поиск происходит через n. Команда, при которой можно заменять слова, следующая :%s/слово для замены/слово замена/g. где : - знак начала команды. % - определение диапазона строк. s - команда подстановки. g - определяет параметр во всех строках документа. Подставив в конец оператор c можно запрашивать подтверждение на каждую замену. 

Редактор vi позволяет открыть несколько файлов, просто перечислив их в аргументах команды через пробел. Для переключения между файлами используйте :n и :N. Переключаться можно только сохранив данные, поэтому можете просто добавлять ! в конце команды. Команда :buffer позволит посмотреть все редактируемые файлы или перейти к одному из них по номеру. Команда :e с именем другого файла откроет его дополнительно в текущем режиме. Команда :r НАЗВАНИЕ_ФАЙЛА вставит содержимое файла после текущей позиции курсора. Чтобы сохранить и выйти можно набрать ZZ, :wq

# 9 Работа с потоками
В Linux три стандартных потока данных:
STDIN - поток ввода = 0
STDOUT - поток вывода = 1 
STDERR - поток ошибок = 2

Это прямо физические файлы, в которые записываются данные по отработке тех или иных команд. 

Поток ввода идет от внешнего оборудования, чаще всего клавиатура или мышь, к программе, сообщает требуемые операции. Программа реагирует через устройство вывода, чаще всего монитор или колонки, выводя корректные результаты обработки программой и ошибки. Чаще всего программы могут принимать и анализировать информацию из потоков других программ. В этом случае то, что для одной программы будет потоком вывода, для другой может стать потоком ввода. Мы можем направить их в файл или другую программу. Именно разделение потоков дает гибкость при работе с ними. Каждый поток имеет свой дискриптор, который для простоты называется номером потока. 

Чтобы направить определенную информацию не на монитор, а в файл, то мы можем использовать аргумент >, перед которым указать номер нужного потока. после этого символа через пробел необходимо указать файл, в который будет записана информация. Одновременно можно направлять поток и вывода, и ошибок, причем в разные файлы. Этот значок перезаписывает всю информацию в файле на новую. Чтобы добавить новую информацию к той, что уже есть, нужно ставить двойной знак >>. Работая с ним, как и прежде. Если файла ранее не существовало - он создастся вновь. Направление может быть и обратным: может принимать данные из вывода другой программы или файла (например grep it '<' file1: Найдет все строки с символами it в файле 1)

Командная оболочка работает с командами перенаправления потоков справа налево, то есть сначала сверяет аргумент с теми данными, которые уже есть в системе, а в случае их отсутствия - создает новый файл. Далее интерпритирует команду направления потока и ее особенность. И только в самом конце рассматривает саму команду. При одновременном создании файла и операции с ним, важно помнить, что команда выполняется на момент создания, то есть до того, как на файл воздействовала команда. Это может привести к ошибкам при написании команд и неполучению желаемого результата.

Для перенаправления вывода одной программы на ввод другой программы необходимо ставить аргумент |, который называется пайп. Такие цепочки выполнения могут быть бесконечно долгими, что позволяет делать любые вещи в ОС. Для комбинирования нам не нужны промежуточные файлы, программы могут передавать поток вывода друг другу напрямую. 

Чтобы увидеть результат работы программы и на мониторе, и записать в файл необходимо воспользоваться командой tee. Если использовать ее чисто - то информация будет перезаписываться. Если указать ключ -a, то информация будет дополняться. 

Чтобы направить более одного потока в одно место необходимо использовать связку "1>___ 2>&1", где вместо ____ будет имя файла для перенаправления. Для подавления отдельного потока, то есть для вывода результатов определенной программы вникуда, используется место в системе Линукс, которое имеет адрес /dev/null. При направлении потока вывода или потока ошибок в него - все данные пропадут. 

В современных системах для вывода результатов потоков вывода и ошибок в одно место достаточно поспользоваться конструкцией &> или &>>. 

# Процессы в Linux
Процесс = программа, которая работает в данный момент. совокупность связанных действий, преобразующих входящие данные в исходящие. Программа - совокупность команд, понятных системе или процессору, совокупность программного кода и ресурсов для его выполнения - становятся уже процессом. 

Создать процесс можно только создав полную копию существующего процесса сделав системный вызов из него самого. Системный вызов с ядром ОС Линукс называется fork(). Стартует в одном процессе, завершается в двух. Далее системный код нужно заменить при помощи исполняемого вызова exec(), принимает имя файла и параметры, применяемые к нему, после чего мы получаем нужный нам процесс. После завершения отработки процесса ставится системный вызов exit(), который прекращает процесс, освобождает используемую им память, закрывает дискрипторы файла, сообщает код возврата процесса. Код возврата считывается системным вызовом wait(), который вызывается из исходного процесса, считывает код возврата и после этого процесс полностью исчезает из системы. Процесс, на основе которого был создан новый процесс называется родителем, а процесс, который был создан - называется потомком. 
  
PID, PPID	PID - уникальный номер идентификатор процесса в ОС, хранится в переменной целочисленного типа (int), где максимальное значение 32768. PPID - идентификатор родительского процесса. Каждый процесс должен иметь PID и PPID. Исключение - процессы init / systemd (PID = 1, PPID = 0) и kthreadd (PID = 2, PPID = 0). Init появляется во время старта ОС и вызван exec из ядра в пространство пользователя. Kthreadd - процесс в пространстве ядра. 

Процесс зомби - состояние процесса после екзит и до вейт. Уже не процесс, не занимает ничего, невозможно завершить, так как нечего завершать, только строчка - код возврата. Но зомби занимает лимит на процессы, выданные отдельным пользователям. Если у пользователя много зомби выбрали весь лимит, но новых процессов он запустить не сможет, новых программ открыть не сможет. Видно в утилите Ток, что показывает, что система высоконагруженная и время между экзит и вейт слишком велико. Это видно и по нагрузке сервера, по среднему числу процессов в очереди. Либо это может значить, что есть процесс, который не следит за своими потомками. Он их создает, но код возврата не считывает. Нужно найти такого родителя. 

Процесс сирота - родительский процесс завершен, соответственно PPID не обращается ни к какому процессу. С сиротами работает само ядро, как только его находит, делает его родительским процессом процесс ИНИТ. Невидим для нас. Как убить зомби? Закрыть родительский процесс, который не принимает коды возврата. Тогда процесс станет сиротой, ИНИТ заберет его коды возврата. Процесс не завершается даже в том случае, если процесс родитель завершен. Тогда новый процесс поменяет родителя, но продолжит выполняться. 

Доступ до ресурсов разграничивается на основе прав пользователей. А процесс - это совокупность файлов и данных. Есть каталог proc, в нем лежат все процессы. Все процессы видны всем. Управлять процессами могут владелец - то, кто создал процесс и пользователь рут. Сменить владельца процесса невозможно. В директории проц лежат файлы с названием равным ПИД процесса. Там можно посмотреть автора процесса - владельца подкаталога в проц. 

Демон - компьютерная программа, которая работает фоном без взаимодействия с пользователем. процесс, который не имеет управляющего терминала, не привязан к терминалу, только при помощи сигналов операционной системы можно им управлять. Также это программы, которые ждут какого-то события, а потом отрабатывают. Не важно, работает ли пользователь на сервере. демоны будут запущены и работать в фоновом режиме. В названии файла в конце если стоит буква d - это демон. Сделано это для программ, процессов, которые должны постоянно поддерживать работу системы. Имеют четкую точку ввода и вывода, независимые от терминалов ввода и вывода. 

kill - программа, которая посылает указанный сигнал определенному процессу. в формате kill -<signal>  <PID>. Любой сигнал завершает процесс, как правило цифровая константа. которая пишется после SIG, иногда имеет словесное отражение. Посикс определяет 28 сигналов, нам стоит помнить SIGINT  = 2 - прерывание, SIGTERM = 15 - завершение, или сигнал по умолчанию, SIGKILL = 9 - безусловное завершение. Кроме того есть 19 - приостановка и 18 - возврат к работе остановленного процесса. Некоторые программы в зависимости от кода могут земенять стандартные обработчики сигналов на свои, что позволит некоторые сигналы игнорировать. На сигнал 15 можно иногда ставить игнорирование, а еще 15 сигнал позволяет программе корректно завершиться  - завершит процессы, освободит файлы, пошлет сигналы и завершится по окончанию всех действий, то есть может потребоваться время. Сигнал 9 невозможно проигнорировать. он моментально отрубает процесс. Сигнал 9 не завершает только процессы d - ожидающие сигналы с устройства вывода, а также ИНИТ. Только в Линукс. В ЮНИКС можно послатть 9 сигнал на инит, перезагрузив систему. 

top - Утилита Линукс, показывающая загрузку системы. присутствует на всех системах семьи Юникс - выводит процессы, наиболее загружающие компьютер. 
- При наборе утилиты топ выводится список процессов в порядке уменьшения потребления времени процессора. 
- Динамический вывод, который обновляется каждые 3 секунды. Можно изменить, набрав S и набрав цифру, на что нужно изменить. 
- В первой строчке показвается время сервера, сколько времени сервер без перезагрузки, сколько пользователей на нем. 

Load average в первой строке показывает в расчете на минуту, на 5 минут, на 15 минут количество процессов в очереди на ожидание пользование ресурсами. Чем больше - тем более нагружена система. Если уменьшается - нагрузка на процессор падает. Если увеличивается - запущены какие-то трудоемкие процессы. Это число должно быть меньше или равно числу ядер процессора для Юникс подобных ОС. 

Нажав 1 - можно посмотреть загруженность каждого из ядер и их число - CPU. 
В Линукс другая ситуация - число лоад эвередж может быть больше, ведь в очередь попадают не только запущенные процессы, но и процессы, которые ожидают данных с устройств ввода - вывода. 
Обращение к недоступному сетевому ресурсу. Процесс получает статус D - , которые ожидает какие-то данные. Они на производительность не влияют, но лоад авередж занимают. 

- Вторая строка утилиты топ показывает число процессов всего и в разных статусах: всего, запущенных, спящих, остановленных, зомби. 
- На третьей строке параметры, которые показывают информацию об объеме потраченного времени:
    - sy - в пространстве ядра ОС, 
    - us - в пространстве пользователя, 
    - ni - на процессы с низким приоритетом (атавизм), 
    - id - простой времени, 
    - wa - на общение с устройством ввода вывода, ожидание данных, чаще всего с диском - самый уязвимый элеменет, 
    - hi - обработка аппаратных прерываний, 
    - si - обработка системных прерываний (напримерторент клиент генерирует, когда растет раздача)
    - st - для виртуальных машин, насколько хостовой сервис нагружен относительно процессорных ресурсов (гипервизор КВМ только общается с процессором, в отличает от других гипервизоров, который считает st)

ps	показать список процессов с ключами -e вывести все процессы в системе, -f показать полностью информацию, -l в длинном виде
pstree	показать дерево процессов в системе.

Состояния процессов, которые можно определить в выводе команды ps x: 
- R Выполняется. Процесс выполняется или готов к выполнению. 
- S Приостановлен. Процесс временно не выполняется; скорее всего, находится в ожидании определенного события, такого как нажатие клавиши или прибытие сетевого пакета. 
- D Приостановлен без возможности прерывания. Процесс ожидает завершения операции ввода/вывода, например, дисковым устройством. 
- T Остановлен. Процесс принудительно остановлен (подробнее об этом рассказывается ниже). 
- Z Недействующий процесс-«зомби». Это дочерний процесс, который завершился, но не был удален родителем. 
- < Высокоприоритетный процесс. Существует возможность наиболее важным процессам выделить больше процессорного времени. Данное свойство процесса называется niceness (уступчивость). Про процессы с более высокими приоритетами говорят, что они менее уступчивы, потому что потребляют больше процессорного времени, оставляя меньше другим процессам. 
- N Низкоприоритетный процесс. Процесс с низким приоритетом (или уступчивый процесс) получает процессорное время только после того, как будут обслужены процессы с более высоким приоритетом. 

Для того, чтобы остановить процесс, который запущен на данный момент в терминале нужно нажать Ctrl+C. 
Комбинация Ctrl+Z позволяет приостановить программу, запущенную в терминале. 

Работа с инициализацией в Linux:

Последовательность событий после запуска компьютера: 
1) сначала программа BIOS проверяет готовность оборудования, проверка систем, 
2) BIOS смотрит в область диска MBR - Master Boot Record - главная загрузочная запись, откуда считывает загрузчик операционной системы. Содержит код загрузки и таблицы разделов. Можно создавать загрузочную область физически на диске. 
3) Запуск GRub - Grand Unifer Bootloader - мощная программа, имеющая доступ до дисков, умеет загружать Линукс, а также передавать права другому загрузчику, например, чтобы загрузить Виндоус. Основная задача - загрузить ядро операционной системы из кодов загрузки. 
4) Загрузка ядра операционной системы. Далее, операционная система должна подмонтировать к корневому каталогу физическая файловая система, для этого обязательно должен быть драйвер. В иных случаях в корневую папку монтируется сначала вместо физического диска initrd. Сюда мы уже можем положить модули и драйверы, которые позволят ядру считать физическую файловую систему. Но чаще мы можем добавлять нужные драйвера напрямую в ядро и собирать операционную систему так, как нам нужно. 
5) Запуск системы инициализации Init или сейчас Systemd. Запускается после запуска ядра, определяет порядок запуска служб и программ, является для всех родителем. Три самые популярные системы инициализации: 
    1 - SysV с 1983 года - набор простых стартовых скриптов по поводу того где и что стартовать и что хранить, Каталоги /etc/rc... определяют последовательность старта разных служб. 
    2 - Upstart, призвана упростить написание стартовых скриптов, сама от себя запускала все службы, но не получила широкого распространения. 
    3 - systemd - упорядоченный процесс запуска служб, который в отличае от предыдущих мог быть параллельным для нескольких программ, последовательность запуска только через зависимости, при незапуске службы - продолжает пытаться запустить программу. Файлы системы инициализации хранятся в /etc/init.d и представляют собой обычный скрипты - сборки программ, которые описывают разные задачи. Каталог для систем инициализации /lib/systemd/system/. Отошла от принципа простых программ. Каждая служба имеет все нужное в себе - нужные ссылки, последовательность запуска.  
6) Запуск пользовательских команд. 

# Сеть

Команда ip a - вывод информации об айпи сервера. 
Команда ip r - вывод информации о шлюзе - пути, по которому пойдут пакеты, не предназначенные для нашей локальной сети. 
Для понимания DNS-сервиса - программы, которая выводит соответствие домена сетевому IP-адресу, к которому сеть обращается. 
Адрес DNS-сервера указывается в специальном файле /etc/resolv.conf. По умолчанию соответствует базовому маршруту - адресу роутера. 
Команда ss -tnlp показывает, какие порты доступны на нашем сервере. 

# Курс по Linux. "Подготовительный курс Linux" от Андрея Буранова, OTUS
### Операционная система - общие сведения
- 0.0.	Введение
- 1.1.	Для чего нужна ОС
- 1.2.	Первая ОС . История Multics
- 1.3.	MS-DOS
- 1.4	Ядро ОС
- 1.5	Кольца защиты и современные ОС
- 1.6	Итоги

### UNIX
- 2.1	История создания
- 2.2	Философия (всё есть файлы)
- 2.3	Стандарт POSIX
- 2.4	Варианты UNIX
- 2.5	Итоги

### Linux
- 3.1	Структура каталогов
- 3.2	Как устанавливается ПО в Linux
- 3.3	Версии Linux
- 3.4	Сложности на пути изучения Linux

### Простые команды
- 4.1	ls - Посмотреть список файлов в каталоге
- 4.2	touch - Создать файл
- 4.3	mkdir - Создать директорию
- 4.4	cd - Сменить текущую директорию
- 4.5	rm - Удалить файл
- 4.6	rmdir - Удалить директорию
- 4.7	cp - Копировать файл или директорию
- 4.8	mv - Переместить файл или директорию
- 4.9	type 
- 4.10	whereis -Узнать внутренняя или внешняя команда
- 4.11	who - Кто сейчас работает на сервере
- 4.12	man - Страница руководства
- 4.13	итоги

### Пользователи
- 5.1	Идентификация пользователя (UID)
- 5.2	root и все остальные
- 5.3	etcpasswd
- 5.4	etcgroup
- 5.5	etcshadow
- 5.6	Права на файлы в Linux
- 5.7	chmod
- 5.8	Файловые системы и inode
- 5.9	Для чего нужны каталоги
- 5.10	HardLink и SoftLink
- 5.11	Итоги

### Работа с файлами
- 6.1	grep
- 6.2	head
- 6.3	tail
- 6.4	more и less
- 6.5	Итоги

### Работа с потоками
- 7.0	Работа с потоками
- 7.1	Перенаправление в файл
- 7.2	Порядок выполнения команды в bash
- 7.3	Перенаправление в STDIN другой команды
- 7.4	tee
- 7.5	потоки и указатели
- 7.6	Итоги

### Логические операции
- 8.1	Код возврата
- 8.2	и
- 8.3	или
- 8.4	не имеет значения
- 8.5	Итоги

### Монтирование
- 9.1 где мои диски
- 9.2 Монтирование
- 9.3 итоги

### Установка ПО
- 10.1, 10.2, 10.3 rpm и yum
- 10.4 список файлов в пакете
- 10.5 Поиск пакета по файлу
- 10.6 список установленных пакетов
- 10.7 итоги

### Процессы
- 11.1 жизненный цикл процесса
- 11.2 PID, PPID
- 11.3 владелец процесса
- 11.4 демон
- 11.5 kill
- 11.6.1 top - Load Average
- 11.6.2 top - Cpu (sy, us, ni, id, wa, hi, si, st)
- 11.7.1 ps -efl
- 11.7.2 работа в консоли
- 11.8 итоги

### Сеть
- 12.1 ip a
- 12.2 ip r
- 12.3 etcresolv.conf
- 12.4 ss -tnlp
- 12.5 итоги

### Системы инициализации
- 13.1 MBR, GRUB, Kernel
- 13.2 SysV, upstart, systemd
- 13.3 итого

- Итоги курса